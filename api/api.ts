/* tslint:disable */
/* eslint-disable */
/**
 * CubePlus Rest API Specifications
 * Gateway API\'s
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AccessToken
 */
export interface AccessToken {
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    'scope'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    'access_token'?: string;
    /**
     * 
     * @type {string}
     * @memberof AccessToken
     */
    'token_type'?: string;
    /**
     * 
     * @type {number}
     * @memberof AccessToken
     */
    'expires_in'?: number;
}
/**
 * 
 * @export
 * @interface Application
 */
export interface Application {
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'appName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'clientID'?: string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'redirectUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'logoUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'clientSecret'?: string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'webhookUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof Application
     */
    'clientCode'?: string;
}
/**
 * List of ASK data
 * @export
 * @interface AskDataList
 */
export interface AskDataList {
    /**
     * 
     * @type {number}
     * @memberof AskDataList
     */
    'no'?: number;
    /**
     * 
     * @type {number}
     * @memberof AskDataList
     */
    'price'?: number;
    /**
     * 
     * @type {number}
     * @memberof AskDataList
     */
    'qty'?: number;
}
/**
 * 
 * @export
 * @interface BankDtls
 */
export interface BankDtls {
    /**
     * 
     * @type {string}
     * @memberof BankDtls
     */
    'bankName'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankDtls
     */
    'accNo'?: string;
    /**
     * 
     * @type {string}
     * @memberof BankDtls
     */
    'ifsc'?: string;
}
/**
 * Basket order is basket of multiple orders
 * @export
 * @interface BasketOrderList
 */
export interface BasketOrderList {
    /**
     * Unique identifier of the symbol
     * @type {string}
     * @memberof BasketOrderList
     */
    'symId': string;
    /**
     * No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.
     * @type {number}
     * @memberof BasketOrderList
     */
    'qty': number;
    /**
     * This is required only for limit and stop limit orders
     * @type {number}
     * @memberof BasketOrderList
     */
    'limitPrice'?: number;
    /**
     * Order side \'buy\' or \'sell\'
     * @type {string}
     * @memberof BasketOrderList
     */
    'side': BasketOrderListSideEnum;
    /**
     * Price type of an order
     * @type {string}
     * @memberof BasketOrderList
     */
    'type': BasketOrderListTypeEnum;
    /**
     * Product type of an order. \'delivery\' is applicable for equities. \'normal\' is applicable for derivatives. \'intraday\' is applicable for both equity and derivatives
     * @type {string}
     * @memberof BasketOrderList
     */
    'product': BasketOrderListProductEnum;
    /**
     * This is required only for stoploss limit and stoploss market orders
     * @type {number}
     * @memberof BasketOrderList
     */
    'trigPrice'?: number;
}

export const BasketOrderListSideEnum = {
    Buy: 'buy',
    Sell: 'sell'
} as const;

export type BasketOrderListSideEnum = typeof BasketOrderListSideEnum[keyof typeof BasketOrderListSideEnum];
export const BasketOrderListTypeEnum = {
    Limit: 'limit',
    Market: 'market',
    Stoplimit: 'stoplimit',
    Stopmarket: 'stopmarket'
} as const;

export type BasketOrderListTypeEnum = typeof BasketOrderListTypeEnum[keyof typeof BasketOrderListTypeEnum];
export const BasketOrderListProductEnum = {
    Delivery: 'delivery',
    Intraday: 'intraday',
    Normal: 'normal'
} as const;

export type BasketOrderListProductEnum = typeof BasketOrderListProductEnum[keyof typeof BasketOrderListProductEnum];

/**
 * 
 * @export
 * @interface BasketOrderMarginData
 */
export interface BasketOrderMarginData {
    /**
     * Required margin
     * @type {number}
     * @memberof BasketOrderMarginData
     */
    'requiredMargin'?: number;
    /**
     * Final margin
     * @type {number}
     * @memberof BasketOrderMarginData
     */
    'finalMargin'?: number;
    /**
     * Existing margin used
     * @type {number}
     * @memberof BasketOrderMarginData
     */
    'existingMarginUsed'?: number;
    /**
     * Combined required margin is a combination of required margin of an order and margin used
     * @type {number}
     * @memberof BasketOrderMarginData
     */
    'combinedRequiredMargin'?: number;
    /**
     * Combined Final margin is a combination of final margin of an order and margin used
     * @type {number}
     * @memberof BasketOrderMarginData
     */
    'combinedFinalMargin'?: number;
    /**
     * Available margin to trade
     * @type {number}
     * @memberof BasketOrderMarginData
     */
    'availableMargin'?: number;
}
/**
 * 
 * @export
 * @interface BasketOrderMarginRequest
 */
export interface BasketOrderMarginRequest {
    /**
     * Basket order is basket of multiple orders
     * @type {Array<BasketOrderList>}
     * @memberof BasketOrderMarginRequest
     */
    'basketOrders'?: Array<BasketOrderList>;
}
/**
 * 
 * @export
 * @interface BasketOrderMarginResponse
 */
export interface BasketOrderMarginResponse {
    /**
     * 
     * @type {string}
     * @memberof BasketOrderMarginResponse
     */
    's'?: BasketOrderMarginResponseSEnum;
    /**
     * 
     * @type {BasketOrderMarginData}
     * @memberof BasketOrderMarginResponse
     */
    'd'?: BasketOrderMarginData;
}

export const BasketOrderMarginResponseSEnum = {
    Ok: 'ok',
    NoData: 'no-data',
    Error: 'error'
} as const;

export type BasketOrderMarginResponseSEnum = typeof BasketOrderMarginResponseSEnum[keyof typeof BasketOrderMarginResponseSEnum];

/**
 * List of BID data
 * @export
 * @interface BidDataList
 */
export interface BidDataList {
    /**
     * 
     * @type {number}
     * @memberof BidDataList
     */
    'no'?: number;
    /**
     * 
     * @type {number}
     * @memberof BidDataList
     */
    'price'?: number;
    /**
     * 
     * @type {number}
     * @memberof BidDataList
     */
    'qty'?: number;
}
/**
 * 
 * @export
 * @interface BiometricRegisterData
 */
export interface BiometricRegisterData {
    /**
     * 
     * @type {string}
     * @memberof BiometricRegisterData
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof BiometricRegisterData
     */
    'biometricID'?: string;
}
/**
 * 
 * @export
 * @interface BoUrlResponseData
 */
export interface BoUrlResponseData {
    /**
     * 
     * @type {string}
     * @memberof BoUrlResponseData
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface BrokerageData
 */
export interface BrokerageData {
    /**
     * 
     * @type {number}
     * @memberof BrokerageData
     */
    'charges'?: number;
    /**
     * 
     * @type {Array<Values>}
     * @memberof BrokerageData
     */
    'detailedView'?: Array<Values>;
}
/**
 * 
 * @export
 * @interface CancelGTTOrder200Response
 */
export interface CancelGTTOrder200Response {
    /**
     * 
     * @type {string}
     * @memberof CancelGTTOrder200Response
     */
    's'?: string;
    /**
     * 
     * @type {CancelGTTOrderData}
     * @memberof CancelGTTOrder200Response
     */
    'd'?: CancelGTTOrderData;
    /**
     * 
     * @type {string}
     * @memberof CancelGTTOrder200Response
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface CancelGTTOrderData
 */
export interface CancelGTTOrderData {
    /**
     * 
     * @type {string}
     * @memberof CancelGTTOrderData
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof CancelGTTOrderData
     */
    'orderId'?: string;
}
/**
 * 
 * @export
 * @interface CancelGTTOrderResponse
 */
export interface CancelGTTOrderResponse {
    /**
     * 
     * @type {string}
     * @memberof CancelGTTOrderResponse
     */
    's'?: CancelGTTOrderResponseSEnum;
    /**
     * 
     * @type {CancelGTTOrderData}
     * @memberof CancelGTTOrderResponse
     */
    'd'?: CancelGTTOrderData;
}

export const CancelGTTOrderResponseSEnum = {
    Ok: 'ok',
    NoData: 'no-data',
    Error: 'error'
} as const;

export type CancelGTTOrderResponseSEnum = typeof CancelGTTOrderResponseSEnum[keyof typeof CancelGTTOrderResponseSEnum];

/**
 * 
 * @export
 * @interface CancelOCOOrder200Response
 */
export interface CancelOCOOrder200Response {
    /**
     * 
     * @type {string}
     * @memberof CancelOCOOrder200Response
     */
    's'?: string;
    /**
     * 
     * @type {CancelOCOOrderData}
     * @memberof CancelOCOOrder200Response
     */
    'd'?: CancelOCOOrderData;
    /**
     * 
     * @type {string}
     * @memberof CancelOCOOrder200Response
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface CancelOCOOrderData
 */
export interface CancelOCOOrderData {
    /**
     * 
     * @type {string}
     * @memberof CancelOCOOrderData
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof CancelOCOOrderData
     */
    'orderId'?: string;
}
/**
 * 
 * @export
 * @interface CancelOCOOrderResponse
 */
export interface CancelOCOOrderResponse {
    /**
     * 
     * @type {string}
     * @memberof CancelOCOOrderResponse
     */
    's'?: CancelOCOOrderResponseSEnum;
    /**
     * 
     * @type {CancelOCOOrderData}
     * @memberof CancelOCOOrderResponse
     */
    'd'?: CancelOCOOrderData;
}

export const CancelOCOOrderResponseSEnum = {
    Ok: 'ok',
    NoData: 'no-data',
    Error: 'error'
} as const;

export type CancelOCOOrderResponseSEnum = typeof CancelOCOOrderResponseSEnum[keyof typeof CancelOCOOrderResponseSEnum];

/**
 * 
 * @export
 * @interface CancelOrder200Response
 */
export interface CancelOrder200Response {
    /**
     * 
     * @type {string}
     * @memberof CancelOrder200Response
     */
    's'?: string;
    /**
     * 
     * @type {CancelOrderData}
     * @memberof CancelOrder200Response
     */
    'd'?: CancelOrderData;
    /**
     * 
     * @type {string}
     * @memberof CancelOrder200Response
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface CancelOrderData
 */
export interface CancelOrderData {
    /**
     * 
     * @type {string}
     * @memberof CancelOrderData
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof CancelOrderData
     */
    'orderId'?: string;
}
/**
 * 
 * @export
 * @interface CancelOrderResponse
 */
export interface CancelOrderResponse {
    /**
     * 
     * @type {string}
     * @memberof CancelOrderResponse
     */
    's'?: CancelOrderResponseSEnum;
    /**
     * 
     * @type {CancelOrderData}
     * @memberof CancelOrderResponse
     */
    'd'?: CancelOrderData;
}

export const CancelOrderResponseSEnum = {
    Ok: 'ok',
    NoData: 'no-data',
    Error: 'error'
} as const;

export type CancelOrderResponseSEnum = typeof CancelOrderResponseSEnum[keyof typeof CancelOrderResponseSEnum];

/**
 * 
 * @export
 * @interface CancelSipOrderData
 */
export interface CancelSipOrderData {
    /**
     * 
     * @type {string}
     * @memberof CancelSipOrderData
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof CancelSipOrderData
     */
    'sipId'?: string;
}
/**
 * 
 * @export
 * @interface ChartDataPointsChartPoints
 */
export interface ChartDataPointsChartPoints {
    /**
     * 
     * @type {Array<Array<ChartPoints>>}
     * @memberof ChartDataPointsChartPoints
     */
    'bars'?: Array<Array<ChartPoints>>;
    /**
     * 
     * @type {number}
     * @memberof ChartDataPointsChartPoints
     */
    'sumUpVolume'?: number;
}
/**
 * 
 * @export
 * @interface ChartPoints
 */
export interface ChartPoints {
    /**
     * 
     * @type {number}
     * @memberof ChartPoints
     */
    'time'?: number;
    /**
     * 
     * @type {number}
     * @memberof ChartPoints
     */
    'open'?: number;
    /**
     * 
     * @type {number}
     * @memberof ChartPoints
     */
    'high'?: number;
    /**
     * 
     * @type {number}
     * @memberof ChartPoints
     */
    'low'?: number;
    /**
     * 
     * @type {number}
     * @memberof ChartPoints
     */
    'close'?: number;
    /**
     * 
     * @type {number}
     * @memberof ChartPoints
     */
    'volume'?: number;
    /**
     * 
     * @type {number}
     * @memberof ChartPoints
     */
    'minuteOi'?: number;
}
/**
 * 
 * @export
 * @interface ChartResp
 */
export interface ChartResp {
    /**
     * 
     * @type {string}
     * @memberof ChartResp
     */
    's'?: ChartRespSEnum;
    /**
     * 
     * @type {ChartDataPointsChartPoints}
     * @memberof ChartResp
     */
    'd'?: ChartDataPointsChartPoints;
}

export const ChartRespSEnum = {
    Ok: 'ok',
    NoData: 'no-data',
    Error: 'error'
} as const;

export type ChartRespSEnum = typeof ChartRespSEnum[keyof typeof ChartRespSEnum];

/**
 * 
 * @export
 * @interface ClientDetailsData
 */
export interface ClientDetailsData {
    /**
     * 
     * @type {string}
     * @memberof ClientDetailsData
     */
    'userId'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientDetailsData
     */
    'userName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientDetailsData
     */
    'mobile'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientDetailsData
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientDetailsData
     */
    'pan'?: string;
    /**
     * 
     * @type {string}
     * @memberof ClientDetailsData
     */
    'dpId'?: string;
    /**
     * 
     * @type {Array<BankDtls>}
     * @memberof ClientDetailsData
     */
    'bankDetails'?: Array<BankDtls>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClientDetailsData
     */
    'dpIds'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClientDetailsData
     */
    'products'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof ClientDetailsData
     */
    'segments'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ClientDetailsResponse
 */
export interface ClientDetailsResponse {
    /**
     * 
     * @type {string}
     * @memberof ClientDetailsResponse
     */
    's'?: ClientDetailsResponseSEnum;
    /**
     * 
     * @type {ClientDetailsData}
     * @memberof ClientDetailsResponse
     */
    'd'?: ClientDetailsData;
}

export const ClientDetailsResponseSEnum = {
    Ok: 'ok',
    NoData: 'no-data',
    Error: 'error'
} as const;

export type ClientDetailsResponseSEnum = typeof ClientDetailsResponseSEnum[keyof typeof ClientDetailsResponseSEnum];

/**
 * 
 * @export
 * @interface ConstituentData
 */
export interface ConstituentData {
    /**
     * 
     * @type {string}
     * @memberof ConstituentData
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof ConstituentData
     */
    'changePer'?: number;
    /**
     * 
     * @type {number}
     * @memberof ConstituentData
     */
    'weightage'?: number;
    /**
     * 
     * @type {number}
     * @memberof ConstituentData
     */
    'contributionPoint'?: number;
}
/**
 * 
 * @export
 * @interface ConvertPosition200Response
 */
export interface ConvertPosition200Response {
    /**
     * 
     * @type {string}
     * @memberof ConvertPosition200Response
     */
    's'?: string;
    /**
     * 
     * @type {IouMessage}
     * @memberof ConvertPosition200Response
     */
    'd'?: IouMessage;
    /**
     * 
     * @type {string}
     * @memberof ConvertPosition200Response
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface ConvertPositionResponse
 */
export interface ConvertPositionResponse {
    /**
     * 
     * @type {string}
     * @memberof ConvertPositionResponse
     */
    's'?: ConvertPositionResponseSEnum;
    /**
     * 
     * @type {IouMessage}
     * @memberof ConvertPositionResponse
     */
    'd'?: IouMessage;
}

export const ConvertPositionResponseSEnum = {
    Ok: 'ok',
    NoData: 'no-data',
    Error: 'error'
} as const;

export type ConvertPositionResponseSEnum = typeof ConvertPositionResponseSEnum[keyof typeof ConvertPositionResponseSEnum];

/**
 * Today\'s position details
 * @export
 * @interface DayPosition
 */
export interface DayPosition {
    /**
     * 
     * @type {number}
     * @memberof DayPosition
     */
    'dayQty'?: number;
    /**
     * 
     * @type {number}
     * @memberof DayPosition
     */
    'dayAvg'?: number;
    /**
     * 
     * @type {number}
     * @memberof DayPosition
     */
    'dayRealizedPnl'?: number;
    /**
     *  dayNetValue is calculated by \'dayBuyValue - daySellValue\'.
     * @type {number}
     * @memberof DayPosition
     */
    'dayNetValue'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof DayPosition
     */
    'convertPos'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof DayPosition
     */
    'dayPremium'?: number;
}
/**
 * 
 * @export
 * @interface DetailedView
 */
export interface DetailedView {
    /**
     * 
     * @type {string}
     * @memberof DetailedView
     */
    'title'?: string;
    /**
     * 
     * @type {number}
     * @memberof DetailedView
     */
    'val'?: number;
    /**
     * 
     * @type {Array<Values>}
     * @memberof DetailedView
     */
    'details'?: Array<Values>;
}
/**
 * 
 * @export
 * @interface ExitOrder200Response
 */
export interface ExitOrder200Response {
    /**
     * 
     * @type {string}
     * @memberof ExitOrder200Response
     */
    's'?: string;
    /**
     * 
     * @type {ExitSnoData}
     * @memberof ExitOrder200Response
     */
    'd'?: ExitSnoData;
    /**
     * 
     * @type {string}
     * @memberof ExitOrder200Response
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface ExitOrderResponse
 */
export interface ExitOrderResponse {
    /**
     * 
     * @type {string}
     * @memberof ExitOrderResponse
     */
    's'?: ExitOrderResponseSEnum;
    /**
     * 
     * @type {ExitSnoData}
     * @memberof ExitOrderResponse
     */
    'd'?: ExitSnoData;
}

export const ExitOrderResponseSEnum = {
    Ok: 'ok',
    NoData: 'no-data',
    Error: 'error'
} as const;

export type ExitOrderResponseSEnum = typeof ExitOrderResponseSEnum[keyof typeof ExitOrderResponseSEnum];

/**
 * 
 * @export
 * @interface ExitSnoData
 */
export interface ExitSnoData {
    /**
     * 
     * @type {string}
     * @memberof ExitSnoData
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface GetBasketOrderMargin200Response
 */
export interface GetBasketOrderMargin200Response {
    /**
     * 
     * @type {string}
     * @memberof GetBasketOrderMargin200Response
     */
    's'?: string;
    /**
     * 
     * @type {BasketOrderMarginData}
     * @memberof GetBasketOrderMargin200Response
     */
    'd'?: BasketOrderMarginData;
    /**
     * 
     * @type {string}
     * @memberof GetBasketOrderMargin200Response
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface GetHoldings200Response
 */
export interface GetHoldings200Response {
    /**
     * 
     * @type {string}
     * @memberof GetHoldings200Response
     */
    's'?: string;
    /**
     * 
     * @type {HoldingData}
     * @memberof GetHoldings200Response
     */
    'd'?: HoldingData;
    /**
     * 
     * @type {string}
     * @memberof GetHoldings200Response
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface GetIntervalChartData200Response
 */
export interface GetIntervalChartData200Response {
    /**
     * 
     * @type {string}
     * @memberof GetIntervalChartData200Response
     */
    's'?: string;
    /**
     * 
     * @type {ChartDataPointsChartPoints}
     * @memberof GetIntervalChartData200Response
     */
    'd'?: ChartDataPointsChartPoints;
    /**
     * 
     * @type {string}
     * @memberof GetIntervalChartData200Response
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface GetLogoutWebResponse200Response
 */
export interface GetLogoutWebResponse200Response {
    /**
     * 
     * @type {string}
     * @memberof GetLogoutWebResponse200Response
     */
    's'?: string;
    /**
     * 
     * @type {IouMessage}
     * @memberof GetLogoutWebResponse200Response
     */
    'd'?: IouMessage;
    /**
     * 
     * @type {string}
     * @memberof GetLogoutWebResponse200Response
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface GetOrderHistory200Response
 */
export interface GetOrderHistory200Response {
    /**
     * 
     * @type {string}
     * @memberof GetOrderHistory200Response
     */
    's'?: string;
    /**
     * 
     * @type {OrderHistoryData}
     * @memberof GetOrderHistory200Response
     */
    'd'?: OrderHistoryData;
    /**
     * 
     * @type {string}
     * @memberof GetOrderHistory200Response
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface GetOrderMargin200Response
 */
export interface GetOrderMargin200Response {
    /**
     * 
     * @type {string}
     * @memberof GetOrderMargin200Response
     */
    's'?: string;
    /**
     * 
     * @type {OrderMarginData}
     * @memberof GetOrderMargin200Response
     */
    'd'?: OrderMarginData;
    /**
     * 
     * @type {string}
     * @memberof GetOrderMargin200Response
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface GetOrders200Response
 */
export interface GetOrders200Response {
    /**
     * 
     * @type {string}
     * @memberof GetOrders200Response
     */
    's'?: string;
    /**
     * 
     * @type {Array<OrderRecord>}
     * @memberof GetOrders200Response
     */
    'd'?: Array<OrderRecord>;
    /**
     * 
     * @type {string}
     * @memberof GetOrders200Response
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface GetPositions200Response
 */
export interface GetPositions200Response {
    /**
     * 
     * @type {string}
     * @memberof GetPositions200Response
     */
    's'?: string;
    /**
     * 
     * @type {Array<PositionRecord>}
     * @memberof GetPositions200Response
     */
    'd'?: Array<PositionRecord>;
    /**
     * 
     * @type {string}
     * @memberof GetPositions200Response
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface GetTrades200Response
 */
export interface GetTrades200Response {
    /**
     * 
     * @type {string}
     * @memberof GetTrades200Response
     */
    's'?: string;
    /**
     * 
     * @type {Array<TradeRecord>}
     * @memberof GetTrades200Response
     */
    'd'?: Array<TradeRecord>;
    /**
     * 
     * @type {string}
     * @memberof GetTrades200Response
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface GetUserDetails200Response
 */
export interface GetUserDetails200Response {
    /**
     * 
     * @type {string}
     * @memberof GetUserDetails200Response
     */
    's'?: string;
    /**
     * 
     * @type {ClientDetailsData}
     * @memberof GetUserDetails200Response
     */
    'd'?: ClientDetailsData;
    /**
     * 
     * @type {string}
     * @memberof GetUserDetails200Response
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface HoldingData
 */
export interface HoldingData {
    /**
     * 
     * @type {Array<Holdings>}
     * @memberof HoldingData
     */
    'holdings'?: Array<Holdings>;
    /**
     * 
     * @type {boolean}
     * @memberof HoldingData
     */
    'hasNonPoaRecord'?: boolean;
}
/**
 * 
 * @export
 * @interface HoldingResponse
 */
export interface HoldingResponse {
    /**
     * 
     * @type {string}
     * @memberof HoldingResponse
     */
    's'?: HoldingResponseSEnum;
    /**
     * 
     * @type {HoldingData}
     * @memberof HoldingResponse
     */
    'd'?: HoldingData;
}

export const HoldingResponseSEnum = {
    Ok: 'ok',
    NoData: 'no-data',
    Error: 'error'
} as const;

export type HoldingResponseSEnum = typeof HoldingResponseSEnum[keyof typeof HoldingResponseSEnum];

/**
 * 
 * @export
 * @interface Holdings
 */
export interface Holdings {
    /**
     * 
     * @type {string}
     * @memberof Holdings
     */
    'symId'?: string;
    /**
     * 
     * @type {TradeRecordSym}
     * @memberof Holdings
     */
    'sym'?: TradeRecordSym;
    /**
     * Quantity is sum of ( btstQuantity, holdingQuantity, brokerQuantity, unPledgedQty, beneficiaryQuantity, MaxOf(nonPoaQuantity,dpQuantity)) minus tradedQuantity
     * @type {number}
     * @memberof Holdings
     */
    'qty'?: number;
    /**
     * Average buy price
     * @type {number}
     * @memberof Holdings
     */
    'avgPrice'?: number;
    /**
     * T1 or BTST quantity
     * @type {number}
     * @memberof Holdings
     */
    't1Qty'?: number;
    /**
     * Saleable quantity is sum of ( btstQuantity, holdingQuantity, unPledgedQty, beneficiaryQuantity, dpQuantity ) minus tradedQty
     * @type {number}
     * @memberof Holdings
     */
    'saleableQty'?: number;
    /**
     * Collateral or pledged quantity
     * @type {number}
     * @memberof Holdings
     */
    'pledgeQty'?: number;
    /**
     * Non POA quantity
     * @type {number}
     * @memberof Holdings
     */
    'nonPoaQty'?: number;
    /**
     * DP holding quantity
     * @type {number}
     * @memberof Holdings
     */
    'dpQty'?: number;
    /**
     * Beneficiary quantity
     * @type {number}
     * @memberof Holdings
     */
    'benQty'?: number;
    /**
     * Unpledged quantity
     * @type {number}
     * @memberof Holdings
     */
    'unpledgedQty'?: number;
    /**
     * Broker collateral
     * @type {number}
     * @memberof Holdings
     */
    'brokerColQty'?: number;
    /**
     * BTST collateral quantity
     * @type {number}
     * @memberof Holdings
     */
    'btstColqty'?: number;
    /**
     * Holding quantity used today
     * @type {number}
     * @memberof Holdings
     */
    'usedQty'?: number;
    /**
     * Holding quantity traded today
     * @type {number}
     * @memberof Holdings
     */
    'tradedQty'?: number;
    /**
     * \'realizedPnL  
     * @type {number}
     * @memberof Holdings
     */
    'realizedPnl'?: number;
    /**
     * 
     * @type {number}
     * @memberof Holdings
     */
    'totalQty'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Holdings
     */
    'transHistory'?: boolean;
}
/**
 * 
 * @export
 * @interface IndexConstituent
 */
export interface IndexConstituent {
    /**
     * 
     * @type {Array<ConstituentData>}
     * @memberof IndexConstituent
     */
    'constituents'?: Array<ConstituentData>;
    /**
     * 
     * @type {number}
     * @memberof IndexConstituent
     */
    'gainerCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof IndexConstituent
     */
    'loserCount'?: number;
    /**
     * 
     * @type {number}
     * @memberof IndexConstituent
     */
    'normalCount'?: number;
}
/**
 * 
 * @export
 * @interface IouMessage
 */
export interface IouMessage {
    /**
     * 
     * @type {string}
     * @memberof IouMessage
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface IouMessageExt
 */
export interface IouMessageExt {
    /**
     * 
     * @type {string}
     * @memberof IouMessageExt
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface IouMessageResponse
 */
export interface IouMessageResponse {
    /**
     * 
     * @type {string}
     * @memberof IouMessageResponse
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof IouMessageResponse
     */
    's'?: string;
}
/**
 * 
 * @export
 * @interface IouResponseScripVersionInfo
 */
export interface IouResponseScripVersionInfo {
    /**
     * 
     * @type {string}
     * @memberof IouResponseScripVersionInfo
     */
    's'?: IouResponseScripVersionInfoSEnum;
    /**
     * 
     * @type {ScripVersionInfo}
     * @memberof IouResponseScripVersionInfo
     */
    'd'?: ScripVersionInfo;
}

export const IouResponseScripVersionInfoSEnum = {
    Ok: 'ok',
    NoData: 'no-data',
    Error: 'error'
} as const;

export type IouResponseScripVersionInfoSEnum = typeof IouResponseScripVersionInfoSEnum[keyof typeof IouResponseScripVersionInfoSEnum];

/**
 * 
 * @export
 * @interface IpoWebUrlData
 */
export interface IpoWebUrlData {
    /**
     * 
     * @type {string}
     * @memberof IpoWebUrlData
     */
    'url'?: string;
}
/**
 * 
 * @export
 * @interface LimitData
 */
export interface LimitData {
    /**
     * Total credits is sum of availableCash, payIn, , adHocMargin, unclearedCash, brokerCollateralAmt,stockCollateral and auxCollateral
     * @type {number}
     * @memberof LimitData
     */
    'totalCredits'?: number;
    /**
     * Available margin is calculated by ( totalcredits - marginused )
     * @type {number}
     * @memberof LimitData
     */
    'availMargin'?: number;
    /**
     * Brokerage amount
     * @type {number}
     * @memberof LimitData
     */
    'brokerage'?: number;
    /**
     * Cash Margin available
     * @type {number}
     * @memberof LimitData
     */
    'availCash'?: number;
    /**
     * Peak margin used by the user
     * @type {number}
     * @memberof LimitData
     */
    'peakMargin'?: number;
    /**
     * Total Amount transferred using Payin\'s today
     * @type {number}
     * @memberof LimitData
     */
    'payIn'?: number;
    /**
     * Span used
     * @type {number}
     * @memberof LimitData
     */
    'span'?: number;
    /**
     * Current realized PnL
     * @type {number}
     * @memberof LimitData
     */
    'realizedPnl'?: number;
    /**
     * Unrealized PnL
     * @type {number}
     * @memberof LimitData
     */
    'unrealizedPnL'?: number;
    /**
     * Exposure margin
     * @type {number}
     * @memberof LimitData
     */
    'exposure'?: number;
    /**
     * Additional leverage amount or the amount added to handle system errors - by broker.
     * @type {number}
     * @memberof LimitData
     */
    'adHocMargin'?: number;
    /**
     * Collateral amount calculated based on uploaded holdings
     * @type {number}
     * @memberof LimitData
     */
    'stockCollateral'?: number;
    /**
     * Derivative Margin
     * @type {number}
     * @memberof LimitData
     */
    'optionPremium'?: number;
    /**
     * Segment
     * @type {string}
     * @memberof LimitData
     */
    'segment'?: string;
    /**
     * Total amount requested for withdrawal today
     * @type {number}
     * @memberof LimitData
     */
    'payOut'?: number;
    /**
     * Broker Collateral Amount
     * @type {number}
     * @memberof LimitData
     */
    'brkCollatAmount'?: number;
    /**
     * Uncleared Cash
     * @type {number}
     * @memberof LimitData
     */
    'unclearedCash'?: number;
    /**
     * Aux day Cash
     * @type {number}
     * @memberof LimitData
     */
    'auxCash'?: number;
    /**
     * 
     * @type {number}
     * @memberof LimitData
     */
    'auxCollatAmount'?: number;
    /**
     * 
     * @type {number}
     * @memberof LimitData
     */
    'auxUnclearedCash'?: number;
    /**
     * Additional leverage amount or the amount added to handle system errors - by broker.
     * @type {number}
     * @memberof LimitData
     */
    'dayCash'?: number;
    /**
     * 
     * @type {number}
     * @memberof LimitData
     */
    'turnOverLmt'?: number;
    /**
     * 
     * @type {number}
     * @memberof LimitData
     */
    'pendOrdValLmt'?: number;
    /**
     * Turnover
     * @type {number}
     * @memberof LimitData
     */
    'turnover'?: number;
    /**
     * Pending Order value
     * @type {number}
     * @memberof LimitData
     */
    'pendOrdValue'?: number;
    /**
     * Total margin or total fund used today
     * @type {number}
     * @memberof LimitData
     */
    'marginUsed'?: number;
    /**
     * Premium used
     * @type {number}
     * @memberof LimitData
     */
    'premium'?: number;
    /**
     * Brokerage Derivative Bracket Order
     * @type {number}
     * @memberof LimitData
     */
    'brokerageDerivativesBO'?: number;
    /**
     * Brokerage Derivative Margin
     * @type {number}
     * @memberof LimitData
     */
    'brokerageDerivativesMargin'?: number;
    /**
     * Option premium Derivative Margin
     * @type {number}
     * @memberof LimitData
     */
    'optPremiumDerMarg'?: number;
}
/**
 * 
 * @export
 * @interface LimitsResponse
 */
export interface LimitsResponse {
    /**
     * 
     * @type {string}
     * @memberof LimitsResponse
     */
    's'?: LimitsResponseSEnum;
    /**
     * 
     * @type {LimitData}
     * @memberof LimitsResponse
     */
    'd'?: LimitData;
}

export const LimitsResponseSEnum = {
    Ok: 'ok',
    NoData: 'no-data',
    Error: 'error'
} as const;

export type LimitsResponseSEnum = typeof LimitsResponseSEnum[keyof typeof LimitsResponseSEnum];

/**
 * 
 * @export
 * @interface LimitsV1Data
 */
export interface LimitsV1Data {
    /**
     * Total credits is sum of availableCash, payIn, , adHocMargin, unclearedCash, brokerCollateralAmt,stockCollateral and auxCollateral
     * @type {number}
     * @memberof LimitsV1Data
     */
    'totalCredits'?: number;
    /**
     * Available margin is calculated by ( totalcredits - marginused )
     * @type {number}
     * @memberof LimitsV1Data
     */
    'availMargin'?: number;
    /**
     * Total margin or total fund used today
     * @type {number}
     * @memberof LimitsV1Data
     */
    'marginUsed'?: number;
    /**
     * 
     * @type {Array<DetailedView>}
     * @memberof LimitsV1Data
     */
    'detailedView'?: Array<DetailedView>;
}
/**
 * 
 * @export
 * @interface LoginData
 */
export interface LoginData {
    /**
     * 
     * @type {string}
     * @memberof LoginData
     */
    'loginTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginData
     */
    'userName'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginData
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginData
     */
    'token'?: string;
    /**
     * 
     * @type {number}
     * @memberof LoginData
     */
    'pinStatus'?: number;
    /**
     * 
     * @type {string}
     * @memberof LoginData
     */
    'mobile'?: string;
    /**
     * 
     * @type {string}
     * @memberof LoginData
     */
    'action'?: LoginDataActionEnum;
}

export const LoginDataActionEnum = {
    Ok: 'ok',
    ChangePassword: 'change-password',
    AccountBlocked: 'account-blocked',
    RegisterAgain: 'register-again'
} as const;

export type LoginDataActionEnum = typeof LoginDataActionEnum[keyof typeof LoginDataActionEnum];

/**
 * 
 * @export
 * @interface LogoutResponse
 */
export interface LogoutResponse {
    /**
     * 
     * @type {string}
     * @memberof LogoutResponse
     */
    's'?: LogoutResponseSEnum;
    /**
     * 
     * @type {IouMessage}
     * @memberof LogoutResponse
     */
    'd'?: IouMessage;
}

export const LogoutResponseSEnum = {
    Ok: 'ok',
    NoData: 'no-data',
    Error: 'error'
} as const;

export type LogoutResponseSEnum = typeof LogoutResponseSEnum[keyof typeof LogoutResponseSEnum];

/**
 * 
 * @export
 * @interface ModifyGTTOrder200Response
 */
export interface ModifyGTTOrder200Response {
    /**
     * 
     * @type {string}
     * @memberof ModifyGTTOrder200Response
     */
    's'?: string;
    /**
     * 
     * @type {ModifyGTTOrderData}
     * @memberof ModifyGTTOrder200Response
     */
    'd'?: ModifyGTTOrderData;
    /**
     * 
     * @type {string}
     * @memberof ModifyGTTOrder200Response
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface ModifyGTTOrderData
 */
export interface ModifyGTTOrderData {
    /**
     * 
     * @type {string}
     * @memberof ModifyGTTOrderData
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModifyGTTOrderData
     */
    'orderId'?: string;
}
/**
 * 
 * @export
 * @interface ModifyGTTOrderResponse
 */
export interface ModifyGTTOrderResponse {
    /**
     * 
     * @type {string}
     * @memberof ModifyGTTOrderResponse
     */
    's'?: ModifyGTTOrderResponseSEnum;
    /**
     * 
     * @type {ModifyGTTOrderData}
     * @memberof ModifyGTTOrderResponse
     */
    'd'?: ModifyGTTOrderData;
}

export const ModifyGTTOrderResponseSEnum = {
    Ok: 'ok',
    NoData: 'no-data',
    Error: 'error'
} as const;

export type ModifyGTTOrderResponseSEnum = typeof ModifyGTTOrderResponseSEnum[keyof typeof ModifyGTTOrderResponseSEnum];

/**
 * 
 * @export
 * @interface ModifyOCOOrder200Response
 */
export interface ModifyOCOOrder200Response {
    /**
     * 
     * @type {string}
     * @memberof ModifyOCOOrder200Response
     */
    's'?: string;
    /**
     * 
     * @type {ModifyOCOOrderData}
     * @memberof ModifyOCOOrder200Response
     */
    'd'?: ModifyOCOOrderData;
    /**
     * 
     * @type {string}
     * @memberof ModifyOCOOrder200Response
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface ModifyOCOOrderData
 */
export interface ModifyOCOOrderData {
    /**
     * 
     * @type {string}
     * @memberof ModifyOCOOrderData
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModifyOCOOrderData
     */
    'orderId'?: string;
}
/**
 * 
 * @export
 * @interface ModifyOCOOrderResponse
 */
export interface ModifyOCOOrderResponse {
    /**
     * 
     * @type {string}
     * @memberof ModifyOCOOrderResponse
     */
    's'?: ModifyOCOOrderResponseSEnum;
    /**
     * 
     * @type {ModifyOCOOrderData}
     * @memberof ModifyOCOOrderResponse
     */
    'd'?: ModifyOCOOrderData;
}

export const ModifyOCOOrderResponseSEnum = {
    Ok: 'ok',
    NoData: 'no-data',
    Error: 'error'
} as const;

export type ModifyOCOOrderResponseSEnum = typeof ModifyOCOOrderResponseSEnum[keyof typeof ModifyOCOOrderResponseSEnum];

/**
 * 
 * @export
 * @interface ModifyOrder200Response
 */
export interface ModifyOrder200Response {
    /**
     * 
     * @type {string}
     * @memberof ModifyOrder200Response
     */
    's'?: string;
    /**
     * 
     * @type {ModifyOrderData}
     * @memberof ModifyOrder200Response
     */
    'd'?: ModifyOrderData;
    /**
     * 
     * @type {string}
     * @memberof ModifyOrder200Response
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface ModifyOrderData
 */
export interface ModifyOrderData {
    /**
     * 
     * @type {string}
     * @memberof ModifyOrderData
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof ModifyOrderData
     */
    'orderId'?: string;
}
/**
 * 
 * @export
 * @interface ModifyOrderResponse
 */
export interface ModifyOrderResponse {
    /**
     * 
     * @type {string}
     * @memberof ModifyOrderResponse
     */
    's'?: ModifyOrderResponseSEnum;
    /**
     * 
     * @type {ModifyOrderData}
     * @memberof ModifyOrderResponse
     */
    'd'?: ModifyOrderData;
}

export const ModifyOrderResponseSEnum = {
    Ok: 'ok',
    NoData: 'no-data',
    Error: 'error'
} as const;

export type ModifyOrderResponseSEnum = typeof ModifyOrderResponseSEnum[keyof typeof ModifyOrderResponseSEnum];

/**
 * 
 * @export
 * @interface ModifySipOrderData
 */
export interface ModifySipOrderData {
    /**
     * 
     * @type {string}
     * @memberof ModifySipOrderData
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface OauthError
 */
export interface OauthError {
    /**
     * 
     * @type {string}
     * @memberof OauthError
     */
    'error'?: string;
    /**
     * 
     * @type {string}
     * @memberof OauthError
     */
    'errorDesc'?: string;
}
/**
 * 
 * @export
 * @interface OrderHistoryData
 */
export interface OrderHistoryData {
    /**
     * 
     * @type {string}
     * @memberof OrderHistoryData
     */
    'orderId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderHistoryData
     */
    'status'?: OrderHistoryDataStatusEnum;
    /**
     * 
     * @type {string}
     * @memberof OrderHistoryData
     */
    'reason'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderHistoryData
     */
    'avgPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderHistoryData
     */
    'totalFillQty'?: number;
    /**
     * Remarks added while placing an order.
     * @type {string}
     * @memberof OrderHistoryData
     */
    'remarks'?: string;
    /**
     * 
     * @type {Array<OrderLog>}
     * @memberof OrderHistoryData
     */
    'history'?: Array<OrderLog>;
}

export const OrderHistoryDataStatusEnum = {
    Open: 'open',
    Completed: 'completed',
    Rejected: 'rejected',
    Cancelled: 'cancelled'
} as const;

export type OrderHistoryDataStatusEnum = typeof OrderHistoryDataStatusEnum[keyof typeof OrderHistoryDataStatusEnum];

/**
 * 
 * @export
 * @interface OrderHistoryResponse
 */
export interface OrderHistoryResponse {
    /**
     * 
     * @type {string}
     * @memberof OrderHistoryResponse
     */
    's'?: OrderHistoryResponseSEnum;
    /**
     * 
     * @type {OrderHistoryData}
     * @memberof OrderHistoryResponse
     */
    'd'?: OrderHistoryData;
}

export const OrderHistoryResponseSEnum = {
    Ok: 'ok',
    NoData: 'no-data',
    Error: 'error'
} as const;

export type OrderHistoryResponseSEnum = typeof OrderHistoryResponseSEnum[keyof typeof OrderHistoryResponseSEnum];

/**
 * 
 * @export
 * @interface OrderLog
 */
export interface OrderLog {
    /**
     * 
     * @type {string}
     * @memberof OrderLog
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderLog
     */
    'fillId'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderLog
     */
    'fillPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderLog
     */
    'fillQty'?: number;
    /**
     * Order log time in the format \'dd-MM-yyyy HH:mm:ss\'
     * @type {string}
     * @memberof OrderLog
     */
    'time'?: string;
}
/**
 * 
 * @export
 * @interface OrderMarginData
 */
export interface OrderMarginData {
    /**
     * Available margin to trade
     * @type {number}
     * @memberof OrderMarginData
     */
    'availableMargin'?: number;
    /**
     * Required margin to trade
     * @type {number}
     * @memberof OrderMarginData
     */
    'requiredMargin'?: number;
    /**
     * 
     * @type {number}
     * @memberof OrderMarginData
     */
    'shortfall'?: number;
    /**
     * This is applicable only for SELL order of Equity ( Delivery )
     * @type {number}
     * @memberof OrderMarginData
     */
    'holdQty'?: number;
    /**
     * Remarks is applicable for failure cases
     * @type {string}
     * @memberof OrderMarginData
     */
    'remarks'?: string;
    /**
     * \'edisAuthEnabled\' flag should be consume in case of edis navigation
     * @type {boolean}
     * @memberof OrderMarginData
     */
    'edisAuthRequired'?: boolean;
}
/**
 * 
 * @export
 * @interface OrderMarginResponse
 */
export interface OrderMarginResponse {
    /**
     * 
     * @type {string}
     * @memberof OrderMarginResponse
     */
    's'?: OrderMarginResponseSEnum;
    /**
     * 
     * @type {OrderMarginData}
     * @memberof OrderMarginResponse
     */
    'd'?: OrderMarginData;
}

export const OrderMarginResponseSEnum = {
    Ok: 'ok',
    NoData: 'no-data',
    Error: 'error'
} as const;

export type OrderMarginResponseSEnum = typeof OrderMarginResponseSEnum[keyof typeof OrderMarginResponseSEnum];

/**
 * 
 * @export
 * @interface OrderRecord
 */
export interface OrderRecord {
    /**
     * 
     * @type {string}
     * @memberof OrderRecord
     */
    'symId'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderRecord
     */
    'status'?: OrderRecordStatusEnum;
    /**
     * Order quantity
     * @type {number}
     * @memberof OrderRecord
     */
    'qty'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrderRecord
     */
    'side'?: OrderRecordSideEnum;
    /**
     * 
     * @type {string}
     * @memberof OrderRecord
     */
    'type'?: OrderRecordTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OrderRecord
     */
    'validity'?: OrderRecordValidityEnum;
    /**
     * 
     * @type {string}
     * @memberof OrderRecord
     */
    'source'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderRecord
     */
    'limitPrice'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrderRecord
     */
    'exchOrderId'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderRecord
     */
    'discQty'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrderRecord
     */
    'product'?: OrderRecordProductEnum;
    /**
     * Exchange order time in the format \'dd-MM-yyyy HH:mm:ss\'
     * @type {string}
     * @memberof OrderRecord
     */
    'exchTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderRecord
     */
    'orderId'?: string;
    /**
     * Order time in the format \'dd-MM-yyyy HH:mm:ss\'
     * @type {string}
     * @memberof OrderRecord
     */
    'orderTime'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderRecord
     */
    'avgPrice'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof OrderRecord
     */
    'amo'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof OrderRecord
     */
    'fillQty'?: number;
    /**
     * This is required only for stoploss limit and stoploss market orders
     * @type {number}
     * @memberof OrderRecord
     */
    'trigPrice'?: number;
    /**
     * 
     * @type {string}
     * @memberof OrderRecord
     */
    'reason'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderRecord
     */
    'pendingQty'?: number;
    /**
     * 
     * @type {TradeRecordSym}
     * @memberof OrderRecord
     */
    'sym'?: TradeRecordSym;
    /**
     * 
     * @type {number}
     * @memberof OrderRecord
     */
    'mktProt'?: number;
    /**
     * Stop loss leg order trigger price.
     * @type {number}
     * @memberof OrderRecord
     */
    'stopTrigPrice'?: number;
    /**
     * Target order or Profit order price
     * @type {number}
     * @memberof OrderRecord
     */
    'targetPrice'?: number;
    /**
     * Trailing stop loss price.
     * @type {number}
     * @memberof OrderRecord
     */
    'trailingStopPrice'?: number;
    /**
     * Remarks added while placing an order.
     * @type {string}
     * @memberof OrderRecord
     */
    'remarks'?: string;
    /**
     * Leg Type. Applicable only for Cover and Bracket order.
     * @type {string}
     * @memberof OrderRecord
     */
    'legType'?: OrderRecordLegTypeEnum;
    /**
     * Main leg order id. Applicable only for Bracket and Cover order. It is used to exit the order.
     * @type {string}
     * @memberof OrderRecord
     */
    'mainLegOrderId'?: string;
    /**
     * 
     * @type {number}
     * @memberof OrderRecord
     */
    'orderValue'?: number;
    /**
     * \'tradeValue\' is filled quantity * average price
     * @type {number}
     * @memberof OrderRecord
     */
    'tradeValue'?: number;
    /**
     * Algo type \'trailing\' or \'regular\' 
     * @type {string}
     * @memberof OrderRecord
     */
    'algType'?: OrderRecordAlgTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof OrderRecord
     */
    'modifiable'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrderRecord
     */
    'cancellable'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof OrderRecord
     */
    'exitable'?: boolean;
}

export const OrderRecordStatusEnum = {
    Open: 'open',
    Completed: 'completed',
    Rejected: 'rejected',
    Cancelled: 'cancelled'
} as const;

export type OrderRecordStatusEnum = typeof OrderRecordStatusEnum[keyof typeof OrderRecordStatusEnum];
export const OrderRecordSideEnum = {
    Buy: 'buy',
    Sell: 'sell'
} as const;

export type OrderRecordSideEnum = typeof OrderRecordSideEnum[keyof typeof OrderRecordSideEnum];
export const OrderRecordTypeEnum = {
    Limit: 'limit',
    Market: 'market',
    Stoplimit: 'stoplimit',
    Stopmarket: 'stopmarket'
} as const;

export type OrderRecordTypeEnum = typeof OrderRecordTypeEnum[keyof typeof OrderRecordTypeEnum];
export const OrderRecordValidityEnum = {
    Day: 'day',
    Ioc: 'ioc',
    Eos: 'eos',
    Gtc: 'gtc'
} as const;

export type OrderRecordValidityEnum = typeof OrderRecordValidityEnum[keyof typeof OrderRecordValidityEnum];
export const OrderRecordProductEnum = {
    Delivery: 'delivery',
    Normal: 'normal',
    Intraday: 'intraday',
    Cover: 'cover',
    Bracket: 'bracket'
} as const;

export type OrderRecordProductEnum = typeof OrderRecordProductEnum[keyof typeof OrderRecordProductEnum];
export const OrderRecordLegTypeEnum = {
    Main: 'main',
    Stoploss: 'stoploss',
    Target: 'target'
} as const;

export type OrderRecordLegTypeEnum = typeof OrderRecordLegTypeEnum[keyof typeof OrderRecordLegTypeEnum];
export const OrderRecordAlgTypeEnum = {
    Trailing: 'trailing',
    Regular: 'regular'
} as const;

export type OrderRecordAlgTypeEnum = typeof OrderRecordAlgTypeEnum[keyof typeof OrderRecordAlgTypeEnum];

/**
 * 
 * @export
 * @interface OrdersResponse
 */
export interface OrdersResponse {
    /**
     * 
     * @type {string}
     * @memberof OrdersResponse
     */
    's'?: OrdersResponseSEnum;
    /**
     * 
     * @type {Array<OrderRecord>}
     * @memberof OrdersResponse
     */
    'd'?: Array<OrderRecord>;
}

export const OrdersResponseSEnum = {
    Ok: 'ok',
    NoData: 'no-data',
    Error: 'error'
} as const;

export type OrdersResponseSEnum = typeof OrdersResponseSEnum[keyof typeof OrdersResponseSEnum];

/**
 * 
 * @export
 * @interface PendingGTTOrderData
 */
export interface PendingGTTOrderData {
    /**
     * 
     * @type {string}
     * @memberof PendingGTTOrderData
     */
    'symId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PendingGTTOrderData
     */
    'exchange'?: string;
    /**
     * 
     * @type {string}
     * @memberof PendingGTTOrderData
     */
    'orderId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PendingGTTOrderData
     */
    'side'?: string;
    /**
     * 
     * @type {string}
     * @memberof PendingGTTOrderData
     */
    'triggerType'?: PendingGTTOrderDataTriggerTypeEnum;
    /**
     * 
     * @type {PlaceOrderParamsData}
     * @memberof PendingGTTOrderData
     */
    'single'?: PlaceOrderParamsData;
    /**
     * 
     * @type {PlaceOrderParamsData}
     * @memberof PendingGTTOrderData
     */
    'stopLoss'?: PlaceOrderParamsData;
    /**
     * 
     * @type {PlaceOrderParamsData}
     * @memberof PendingGTTOrderData
     */
    'target'?: PlaceOrderParamsData;
}

export const PendingGTTOrderDataTriggerTypeEnum = {
    Single: 'Single',
    Oco: 'OCO'
} as const;

export type PendingGTTOrderDataTriggerTypeEnum = typeof PendingGTTOrderDataTriggerTypeEnum[keyof typeof PendingGTTOrderDataTriggerTypeEnum];

/**
 * 
 * @export
 * @interface PendingGTTOrderResponse
 */
export interface PendingGTTOrderResponse {
    /**
     * 
     * @type {string}
     * @memberof PendingGTTOrderResponse
     */
    's'?: PendingGTTOrderResponseSEnum;
    /**
     * 
     * @type {Array<PendingGTTOrderData>}
     * @memberof PendingGTTOrderResponse
     */
    'd'?: Array<PendingGTTOrderData>;
}

export const PendingGTTOrderResponseSEnum = {
    Ok: 'ok',
    NoData: 'no-data',
    Error: 'error'
} as const;

export type PendingGTTOrderResponseSEnum = typeof PendingGTTOrderResponseSEnum[keyof typeof PendingGTTOrderResponseSEnum];

/**
 * 
 * @export
 * @interface PendingGTTOrders200Response
 */
export interface PendingGTTOrders200Response {
    /**
     * 
     * @type {string}
     * @memberof PendingGTTOrders200Response
     */
    's'?: string;
    /**
     * 
     * @type {Array<PendingGTTOrderData>}
     * @memberof PendingGTTOrders200Response
     */
    'd'?: Array<PendingGTTOrderData>;
    /**
     * 
     * @type {string}
     * @memberof PendingGTTOrders200Response
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface PlaceBracketOrder200Response
 */
export interface PlaceBracketOrder200Response {
    /**
     * 
     * @type {string}
     * @memberof PlaceBracketOrder200Response
     */
    's'?: string;
    /**
     * 
     * @type {PlaceOrderData}
     * @memberof PlaceBracketOrder200Response
     */
    'd'?: PlaceOrderData;
    /**
     * 
     * @type {string}
     * @memberof PlaceBracketOrder200Response
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface PlaceGTTOrder200Response
 */
export interface PlaceGTTOrder200Response {
    /**
     * 
     * @type {string}
     * @memberof PlaceGTTOrder200Response
     */
    's'?: string;
    /**
     * 
     * @type {PlaceGTTOrderData}
     * @memberof PlaceGTTOrder200Response
     */
    'd'?: PlaceGTTOrderData;
    /**
     * 
     * @type {string}
     * @memberof PlaceGTTOrder200Response
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface PlaceGTTOrderData
 */
export interface PlaceGTTOrderData {
    /**
     * 
     * @type {string}
     * @memberof PlaceGTTOrderData
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlaceGTTOrderData
     */
    'orderId'?: string;
}
/**
 * 
 * @export
 * @interface PlaceGTTOrderResponse
 */
export interface PlaceGTTOrderResponse {
    /**
     * 
     * @type {string}
     * @memberof PlaceGTTOrderResponse
     */
    's'?: PlaceGTTOrderResponseSEnum;
    /**
     * 
     * @type {PlaceGTTOrderData}
     * @memberof PlaceGTTOrderResponse
     */
    'd'?: PlaceGTTOrderData;
}

export const PlaceGTTOrderResponseSEnum = {
    Ok: 'ok',
    NoData: 'no-data',
    Error: 'error'
} as const;

export type PlaceGTTOrderResponseSEnum = typeof PlaceGTTOrderResponseSEnum[keyof typeof PlaceGTTOrderResponseSEnum];

/**
 * 
 * @export
 * @interface PlaceOCOOrder200Response
 */
export interface PlaceOCOOrder200Response {
    /**
     * 
     * @type {string}
     * @memberof PlaceOCOOrder200Response
     */
    's'?: string;
    /**
     * 
     * @type {PlaceOCOOrderData}
     * @memberof PlaceOCOOrder200Response
     */
    'd'?: PlaceOCOOrderData;
    /**
     * 
     * @type {string}
     * @memberof PlaceOCOOrder200Response
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface PlaceOCOOrderData
 */
export interface PlaceOCOOrderData {
    /**
     * 
     * @type {string}
     * @memberof PlaceOCOOrderData
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlaceOCOOrderData
     */
    'orderId'?: string;
}
/**
 * 
 * @export
 * @interface PlaceOCOOrderResponse
 */
export interface PlaceOCOOrderResponse {
    /**
     * 
     * @type {string}
     * @memberof PlaceOCOOrderResponse
     */
    's'?: PlaceOCOOrderResponseSEnum;
    /**
     * 
     * @type {PlaceOCOOrderData}
     * @memberof PlaceOCOOrderResponse
     */
    'd'?: PlaceOCOOrderData;
}

export const PlaceOCOOrderResponseSEnum = {
    Ok: 'ok',
    NoData: 'no-data',
    Error: 'error'
} as const;

export type PlaceOCOOrderResponseSEnum = typeof PlaceOCOOrderResponseSEnum[keyof typeof PlaceOCOOrderResponseSEnum];

/**
 * 
 * @export
 * @interface PlaceOrder200Response
 */
export interface PlaceOrder200Response {
    /**
     * 
     * @type {string}
     * @memberof PlaceOrder200Response
     */
    's'?: PlaceOrder200ResponseSEnum;
    /**
     * 
     * @type {PlaceOrderData}
     * @memberof PlaceOrder200Response
     */
    'd'?: PlaceOrderData;
    /**
     * 
     * @type {string}
     * @memberof PlaceOrder200Response
     */
    'msg'?: string;
}

export const PlaceOrder200ResponseSEnum = {
    Ok: 'ok',
    NoData: 'no-data',
    Error: 'error'
} as const;

export type PlaceOrder200ResponseSEnum = typeof PlaceOrder200ResponseSEnum[keyof typeof PlaceOrder200ResponseSEnum];

/**
 * 
 * @export
 * @interface PlaceOrderData
 */
export interface PlaceOrderData {
    /**
     * 
     * @type {string}
     * @memberof PlaceOrderData
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlaceOrderData
     */
    'orderId'?: string;
}
/**
 * 
 * @export
 * @interface PlaceOrderParamsData
 */
export interface PlaceOrderParamsData {
    /**
     * Any message entered during order entry
     * @type {string}
     * @memberof PlaceOrderParamsData
     */
    'remarks'?: string;
    /**
     * Trigger price with respect to LTP
     * @type {number}
     * @memberof PlaceOrderParamsData
     */
    'trigPrice'?: number;
    /**
     * Product type of an order. \'delivery\' is applicable for equities. \'normal\' is applicable for derivatives. \'intraday\' is applicable for both equity and derivatives
     * @type {string}
     * @memberof PlaceOrderParamsData
     */
    'product'?: PlaceOrderParamsDataProductEnum;
    /**
     * 
     * @type {string}
     * @memberof PlaceOrderParamsData
     */
    'type'?: PlaceOrderParamsDataTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof PlaceOrderParamsData
     */
    'qty'?: number;
    /**
     * 
     * @type {number}
     * @memberof PlaceOrderParamsData
     */
    'price'?: number;
}

export const PlaceOrderParamsDataProductEnum = {
    Delivery: 'delivery',
    Normal: 'normal'
} as const;

export type PlaceOrderParamsDataProductEnum = typeof PlaceOrderParamsDataProductEnum[keyof typeof PlaceOrderParamsDataProductEnum];
export const PlaceOrderParamsDataTypeEnum = {
    Limit: 'limit'
} as const;

export type PlaceOrderParamsDataTypeEnum = typeof PlaceOrderParamsDataTypeEnum[keyof typeof PlaceOrderParamsDataTypeEnum];

/**
 * 
 * @export
 * @interface PlaceOrderResponse
 */
export interface PlaceOrderResponse {
    /**
     * 
     * @type {string}
     * @memberof PlaceOrderResponse
     */
    's'?: PlaceOrderResponseSEnum;
    /**
     * 
     * @type {PlaceOrderData}
     * @memberof PlaceOrderResponse
     */
    'd'?: PlaceOrderData;
}

export const PlaceOrderResponseSEnum = {
    Ok: 'ok',
    NoData: 'no-data',
    Error: 'error'
} as const;

export type PlaceOrderResponseSEnum = typeof PlaceOrderResponseSEnum[keyof typeof PlaceOrderResponseSEnum];

/**
 * 
 * @export
 * @interface PlaceTrailOrderData
 */
export interface PlaceTrailOrderData {
    /**
     * 
     * @type {string}
     * @memberof PlaceTrailOrderData
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlaceTrailOrderData
     */
    'orderId'?: string;
}
/**
 * 
 * @export
 * @interface PositionRecord
 */
export interface PositionRecord {
    /**
     * 
     * @type {string}
     * @memberof PositionRecord
     */
    'symId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PositionRecord
     */
    'product'?: PositionRecordProductEnum;
    /**
     * 
     * @type {number}
     * @memberof PositionRecord
     */
    'buyQty'?: number;
    /**
     * 
     * @type {number}
     * @memberof PositionRecord
     */
    'buyValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof PositionRecord
     */
    'buyAvgPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof PositionRecord
     */
    'sellQty'?: number;
    /**
     * 
     * @type {number}
     * @memberof PositionRecord
     */
    'sellValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof PositionRecord
     */
    'sellAvgPrice'?: number;
    /**
     * Carry forward positions quantity
     * @type {number}
     * @memberof PositionRecord
     */
    'cfQty'?: number;
    /**
     * Carry forward position value and it is calculated using cfQty * cfAvgPrice * multiplier * pricefactor.
     * @type {number}
     * @memberof PositionRecord
     */
    'cfValue'?: number;
    /**
     * The settlement price of the scrip from the last trading day, is used to calculate the mark-to-market (MTM) of the positions
     * @type {number}
     * @memberof PositionRecord
     */
    'cfAvgPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof PositionRecord
     */
    'netQty'?: number;
    /**
     * The net average price is based on today\'s positions and carryforward positions. For carryforward positions, the average would be the settlement price from the last trading day (cfavgprice), while for today\'s positions, the average would be the day average price (dayavgprice)
     * @type {number}
     * @memberof PositionRecord
     */
    'netAvgPrice'?: number;
    /**
     * Net value of the position based on the net average price (netavgprice)
     * @type {number}
     * @memberof PositionRecord
     */
    'netValue'?: number;
    /**
     * Realized pnl value
     * @type {number}
     * @memberof PositionRecord
     */
    'realizedPnl'?: number;
    /**
     * Used for pnl calculations. PriceFactor:(General Numerator * Price Numerator)/(General Denominator * Price Denopminator)
     * @type {number}
     * @memberof PositionRecord
     */
    'priceFactor'?: number;
    /**
     * 
     * @type {number}
     * @memberof PositionRecord
     */
    'multiplier'?: number;
    /**
     * 
     * @type {TradeRecordSym}
     * @memberof PositionRecord
     */
    'sym'?: TradeRecordSym;
    /**
     * The actual buy/sell price of the position, is used to calculate the overall PNL of the positions.
     * @type {number}
     * @memberof PositionRecord
     */
    'cfOrgAvgPrice'?: number;
    /**
     * Carry forward position original value and it is calculated using cfQty * cfOrgAvgPrice * multiplier * pricefactor
     * @type {number}
     * @memberof PositionRecord
     */
    'cfOrgValue'?: number;
    /**
     * The net original average price is based on today\'s positions and carryforward positions. For carryforward positions, the average would be the actual buy or sell price of the scrip, while for today\'s positions, the average would be the day average price (dayavgprice)
     * @type {number}
     * @memberof PositionRecord
     */
    'netOrgAvgPrice'?: number;
    /**
     * Net original value of the position based on the net original average price (netorgavgprice)
     * @type {number}
     * @memberof PositionRecord
     */
    'netOrgValue'?: number;
    /**
     * 
     * @type {number}
     * @memberof PositionRecord
     */
    'realizedOrgPnl'?: number;
    /**
     * 
     * @type {DayPosition}
     * @memberof PositionRecord
     */
    'dayPos'?: DayPosition;
    /**
     * 
     * @type {boolean}
     * @memberof PositionRecord
     */
    'convertPos'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PositionRecord
     */
    'netPremium'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PositionRecord
     */
    'transHistory'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PositionRecord
     */
    'createTSL'?: boolean;
}

export const PositionRecordProductEnum = {
    Delivery: 'delivery',
    Normal: 'normal',
    Intraday: 'intraday',
    Cover: 'cover',
    Bracket: 'bracket'
} as const;

export type PositionRecordProductEnum = typeof PositionRecordProductEnum[keyof typeof PositionRecordProductEnum];

/**
 * 
 * @export
 * @interface PositionsResponse
 */
export interface PositionsResponse {
    /**
     * 
     * @type {string}
     * @memberof PositionsResponse
     */
    's'?: PositionsResponseSEnum;
    /**
     * 
     * @type {Array<PositionRecord>}
     * @memberof PositionsResponse
     */
    'd'?: Array<PositionRecord>;
}

export const PositionsResponseSEnum = {
    Ok: 'ok',
    NoData: 'no-data',
    Error: 'error'
} as const;

export type PositionsResponseSEnum = typeof PositionsResponseSEnum[keyof typeof PositionsResponseSEnum];

/**
 * 
 * @export
 * @interface PreLogin
 */
export interface PreLogin {
    /**
     * 
     * @type {boolean}
     * @memberof PreLogin
     */
    'preLogin'?: boolean;
}
/**
 * 
 * @export
 * @interface PriceShocker
 */
export interface PriceShocker {
    /**
     * 
     * @type {string}
     * @memberof PriceShocker
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PriceShocker
     */
    'changePer'?: string;
    /**
     * 
     * @type {string}
     * @memberof PriceShocker
     */
    'avgPrice'?: string;
}
/**
 * 
 * @export
 * @interface RetrieveFundsLimits200Response
 */
export interface RetrieveFundsLimits200Response {
    /**
     * 
     * @type {string}
     * @memberof RetrieveFundsLimits200Response
     */
    's'?: string;
    /**
     * 
     * @type {LimitData}
     * @memberof RetrieveFundsLimits200Response
     */
    'd'?: LimitData;
    /**
     * 
     * @type {string}
     * @memberof RetrieveFundsLimits200Response
     */
    'msg'?: string;
}
/**
 * 
 * @export
 * @interface SSOLoginData
 */
export interface SSOLoginData {
    /**
     * 
     * @type {string}
     * @memberof SSOLoginData
     */
    'loginTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof SSOLoginData
     */
    'userName'?: string;
    /**
     * 
     * @type {string}
     * @memberof SSOLoginData
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof SSOLoginData
     */
    'token'?: string;
    /**
     * 
     * @type {number}
     * @memberof SSOLoginData
     */
    'pinStatus'?: number;
    /**
     * 
     * @type {string}
     * @memberof SSOLoginData
     */
    'action'?: SSOLoginDataActionEnum;
}

export const SSOLoginDataActionEnum = {
    Ok: 'ok',
    ChangePassword: 'change-password',
    AccountBlocked: 'account-blocked',
    RegisterAgain: 'register-again'
} as const;

export type SSOLoginDataActionEnum = typeof SSOLoginDataActionEnum[keyof typeof SSOLoginDataActionEnum];

/**
 * 
 * @export
 * @interface ScripInfo
 */
export interface ScripInfo {
    /**
     * Unique identifier of the symbol
     * @type {string}
     * @memberof ScripInfo
     */
    'symId'?: string;
    /**
     * Investment type should be in qty or amount 
     * @type {string}
     * @memberof ScripInfo
     */
    'investBy'?: ScripInfoInvestByEnum;
    /**
     * No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.
     * @type {number}
     * @memberof ScripInfo
     */
    'qty'?: number;
    /**
     * Amount
     * @type {number}
     * @memberof ScripInfo
     */
    'amount'?: number;
}

export const ScripInfoInvestByEnum = {
    Qty: 'qty',
    Amount: 'amount'
} as const;

export type ScripInfoInvestByEnum = typeof ScripInfoInvestByEnum[keyof typeof ScripInfoInvestByEnum];

/**
 * 
 * @export
 * @interface ScripList
 */
export interface ScripList {
    /**
     * 
     * @type {string}
     * @memberof ScripList
     */
    's'?: ScripListSEnum;
    /**
     * 
     * @type {Array<SymbolStoreJson>}
     * @memberof ScripList
     */
    'd'?: Array<SymbolStoreJson>;
}

export const ScripListSEnum = {
    Ok: 'ok',
    NoData: 'no-data',
    Error: 'error'
} as const;

export type ScripListSEnum = typeof ScripListSEnum[keyof typeof ScripListSEnum];

/**
 * 
 * @export
 * @interface ScripVersionInfo
 */
export interface ScripVersionInfo {
    /**
     * 
     * @type {number}
     * @memberof ScripVersionInfo
     */
    'version'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ScripVersionInfo
     */
    'updated'?: boolean;
    /**
     * 
     * @type {Array<SymbolStoreData>}
     * @memberof ScripVersionInfo
     */
    'symbolStore'?: Array<SymbolStoreData>;
}
/**
 * 
 * @export
 * @interface SecretData
 */
export interface SecretData {
    /**
     * 
     * @type {string}
     * @memberof SecretData
     */
    'key'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecretData
     */
    'algo': SecretDataAlgoEnum;
    /**
     * 
     * @type {string}
     * @memberof SecretData
     */
    'totpUrl'?: string;
}

export const SecretDataAlgoEnum = {
    Sha1: 'SHA1',
    Sha256: 'SHA256',
    Sha512: 'SHA512'
} as const;

export type SecretDataAlgoEnum = typeof SecretDataAlgoEnum[keyof typeof SecretDataAlgoEnum];

/**
 * 
 * @export
 * @interface SecurityInfo
 */
export interface SecurityInfo {
    /**
     * 
     * @type {string}
     * @memberof SecurityInfo
     */
    'symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityInfo
     */
    'segment'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityInfo
     */
    'expiry'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityInfo
     */
    'instrument'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityInfo
     */
    'tickSize'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityInfo
     */
    'lotSize'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityInfo
     */
    'multiplier'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityInfo
     */
    'gnGdBypnPd'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityInfo
     */
    'priceUnit'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityInfo
     */
    'priceQuoteQty'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityInfo
     */
    'tradeUnit'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityInfo
     */
    'deliveryUnit'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityInfo
     */
    'freezeQty'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityInfo
     */
    'additionalLongMgn'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityInfo
     */
    'additionalShortMgn'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityInfo
     */
    'exerciseStartDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityInfo
     */
    'exerciseEndDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityInfo
     */
    'tenderStartDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityInfo
     */
    'tenderEndDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityInfo
     */
    'elmBuyMgn'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityInfo
     */
    'elmStartMgn'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityInfo
     */
    'specialLongMgn'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityInfo
     */
    'specialShortMgn'?: string;
    /**
     * 
     * @type {string}
     * @memberof SecurityInfo
     */
    'contractToken'?: string;
}
/**
 * 
 * @export
 * @interface SipOrderRecord
 */
export interface SipOrderRecord {
    /**
     * 
     * @type {string}
     * @memberof SipOrderRecord
     */
    'sipName'?: string;
    /**
     * 
     * @type {string}
     * @memberof SipOrderRecord
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof SipOrderRecord
     */
    'sipType': SipOrderRecordSipTypeEnum;
    /**
     * \'modifyStartDate\' flag will be false if modification of start date is disabled
     * @type {boolean}
     * @memberof SipOrderRecord
     */
    'modifyStartDate'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof SipOrderRecord
     */
    'registeredDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof SipOrderRecord
     */
    'startDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof SipOrderRecord
     */
    'dueDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof SipOrderRecord
     */
    'lastExecutedDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof SipOrderRecord
     */
    'executionDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof SipOrderRecord
     */
    'sipId'?: string;
    /**
     * End period
     * @type {number}
     * @memberof SipOrderRecord
     */
    'pendingPeriod'?: number;
    /**
     * 
     * @type {number}
     * @memberof SipOrderRecord
     */
    'period'?: number;
    /**
     * 
     * @type {number}
     * @memberof SipOrderRecord
     */
    'executedPeriod'?: number;
    /**
     * 
     * @type {string}
     * @memberof SipOrderRecord
     */
    'scheduleDesc'?: string;
    /**
     * 
     * @type {Array<ScripInfo>}
     * @memberof SipOrderRecord
     */
    'symbols'?: Array<ScripInfo>;
}

export const SipOrderRecordSipTypeEnum = {
    Daily: 'daily',
    Weekly: 'weekly',
    Fortnightly: 'fortnightly',
    Monthly: 'monthly'
} as const;

export type SipOrderRecordSipTypeEnum = typeof SipOrderRecordSipTypeEnum[keyof typeof SipOrderRecordSipTypeEnum];

/**
 * 
 * @export
 * @interface SipPlaceOrderData
 */
export interface SipPlaceOrderData {
    /**
     * 
     * @type {string}
     * @memberof SipPlaceOrderData
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof SipPlaceOrderData
     */
    'sipId'?: string;
}
/**
 * 
 * @export
 * @interface StageMessage
 */
export interface StageMessage {
    /**
     * 
     * @type {string}
     * @memberof StageMessage
     */
    'msg'?: string;
    /**
     * severity of surveillance stage measure
     * @type {string}
     * @memberof StageMessage
     */
    'risk'?: StageMessageRiskEnum;
}

export const StageMessageRiskEnum = {
    High: 'high',
    Low: 'low',
    Medium: 'medium'
} as const;

export type StageMessageRiskEnum = typeof StageMessageRiskEnum[keyof typeof StageMessageRiskEnum];

/**
 * 
 * @export
 * @interface SymList
 */
export interface SymList {
    /**
     * 
     * @type {string}
     * @memberof SymList
     */
    's'?: SymListSEnum;
    /**
     * 
     * @type {Array<string>}
     * @memberof SymList
     */
    'd'?: Array<string>;
}

export const SymListSEnum = {
    Ok: 'ok',
    NoData: 'no-data',
    Error: 'error'
} as const;

export type SymListSEnum = typeof SymListSEnum[keyof typeof SymListSEnum];

/**
 * 
 * @export
 * @interface SymbolStoreAppender
 */
export interface SymbolStoreAppender {
    /**
     * 
     * @type {string}
     * @memberof SymbolStoreAppender
     */
    'data'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SymbolStoreAppender
     */
    'buildVersion'?: Array<string>;
}
/**
 * 
 * @export
 * @interface SymbolStoreData
 */
export interface SymbolStoreData {
    /**
     * 
     * @type {string}
     * @memberof SymbolStoreData
     */
    'name'?: string;
    /**
     * 
     * @type {number}
     * @memberof SymbolStoreData
     */
    'sortOrder'?: number;
    /**
     * 
     * @type {string}
     * @memberof SymbolStoreData
     */
    'idFormat'?: string;
    /**
     * 
     * @type {string}
     * @memberof SymbolStoreData
     */
    'data'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SymbolStoreData
     */
    'buildVersion'?: Array<string>;
    /**
     * 
     * @type {SymbolStoreAppender}
     * @memberof SymbolStoreData
     */
    'append'?: SymbolStoreAppender;
}
/**
 * 
 * @export
 * @interface SymbolStoreJson
 */
export interface SymbolStoreJson {
    /**
     * 
     * @type {string}
     * @memberof SymbolStoreJson
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof SymbolStoreJson
     */
    'isin'?: string;
    /**
     * 
     * @type {string}
     * @memberof SymbolStoreJson
     */
    'dispName'?: string;
    /**
     * 
     * @type {string}
     * @memberof SymbolStoreJson
     */
    'desc'?: string;
    /**
     * 
     * @type {string}
     * @memberof SymbolStoreJson
     */
    'excToken'?: string;
    /**
     * 
     * @type {string}
     * @memberof SymbolStoreJson
     */
    'lot'?: string;
    /**
     * 
     * @type {string}
     * @memberof SymbolStoreJson
     */
    'tick'?: string;
    /**
     * 
     * @type {string}
     * @memberof SymbolStoreJson
     */
    'expiry'?: string;
    /**
     * 
     * @type {string}
     * @memberof SymbolStoreJson
     */
    'strike'?: string;
    /**
     * 
     * @type {string}
     * @memberof SymbolStoreJson
     */
    'optType'?: string;
    /**
     * 
     * @type {string}
     * @memberof SymbolStoreJson
     */
    'weekly'?: string;
    /**
     * 
     * @type {string}
     * @memberof SymbolStoreJson
     */
    'asset'?: string;
    /**
     * 
     * @type {string}
     * @memberof SymbolStoreJson
     */
    'instrument'?: string;
    /**
     * 
     * @type {string}
     * @memberof SymbolStoreJson
     */
    'symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof SymbolStoreJson
     */
    'series'?: string;
    /**
     * 
     * @type {string}
     * @memberof SymbolStoreJson
     */
    'exchange'?: string;
    /**
     * 
     * @type {string}
     * @memberof SymbolStoreJson
     */
    'freezeQty'?: string;
    /**
     * 
     * @type {string}
     * @memberof SymbolStoreJson
     */
    'undId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SymbolStoreJson
     */
    'trdUnit'?: string;
    /**
     * 
     * @type {string}
     * @memberof SymbolStoreJson
     */
    'lotMulti'?: string;
}
/**
 * 
 * @export
 * @interface TradeRecord
 */
export interface TradeRecord {
    /**
     * 
     * @type {string}
     * @memberof TradeRecord
     */
    'symId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TradeRecord
     */
    'side'?: TradeRecordSideEnum;
    /**
     * 
     * @type {string}
     * @memberof TradeRecord
     */
    'type'?: TradeRecordTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TradeRecord
     */
    'validity'?: TradeRecordValidityEnum;
    /**
     * 
     * @type {string}
     * @memberof TradeRecord
     */
    'product'?: TradeRecordProductEnum;
    /**
     * 
     * @type {string}
     * @memberof TradeRecord
     */
    'orderId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TradeRecord
     */
    'fillId'?: string;
    /**
     * 
     * @type {number}
     * @memberof TradeRecord
     */
    'fillQty'?: number;
    /**
     * 
     * @type {number}
     * @memberof TradeRecord
     */
    'fillPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof TradeRecord
     */
    'fillValue'?: number;
    /**
     * Traded time in the format \'dd-MM-yyyy HH:mm:ss\'
     * @type {string}
     * @memberof TradeRecord
     */
    'time'?: string;
    /**
     * 
     * @type {string}
     * @memberof TradeRecord
     */
    'exchOrderId'?: string;
    /**
     * 
     * @type {number}
     * @memberof TradeRecord
     */
    'avgPrice'?: number;
    /**
     * 
     * @type {TradeRecordSym}
     * @memberof TradeRecord
     */
    'sym'?: TradeRecordSym;
    /**
     * Remarks added while placing an order.
     * @type {string}
     * @memberof TradeRecord
     */
    'remarks'?: string;
    /**
     * Leg Type. Applicable only for Cover and Bracket order.
     * @type {string}
     * @memberof TradeRecord
     */
    'legType'?: string;
    /**
     * Main leg order id. Applicable only for Bracket and Cover order. It is used to exit the order.
     * @type {string}
     * @memberof TradeRecord
     */
    'mainLegOrderId'?: string;
}

export const TradeRecordSideEnum = {
    Buy: 'buy',
    Sell: 'sell'
} as const;

export type TradeRecordSideEnum = typeof TradeRecordSideEnum[keyof typeof TradeRecordSideEnum];
export const TradeRecordTypeEnum = {
    Limit: 'limit',
    Market: 'market',
    Stoplimit: 'stoplimit',
    Stopmarket: 'stopmarket'
} as const;

export type TradeRecordTypeEnum = typeof TradeRecordTypeEnum[keyof typeof TradeRecordTypeEnum];
export const TradeRecordValidityEnum = {
    Day: 'day',
    Ioc: 'ioc',
    Eos: 'eos',
    Gtc: 'gtc'
} as const;

export type TradeRecordValidityEnum = typeof TradeRecordValidityEnum[keyof typeof TradeRecordValidityEnum];
export const TradeRecordProductEnum = {
    Delivery: 'delivery',
    Normal: 'normal',
    Intraday: 'intraday',
    Cover: 'cover',
    Bracket: 'bracket'
} as const;

export type TradeRecordProductEnum = typeof TradeRecordProductEnum[keyof typeof TradeRecordProductEnum];

/**
 * 
 * @export
 * @interface TradeRecordSym
 */
export interface TradeRecordSym {
    [key: string]: object;

    /**
     * 
     * @type {string}
     * @memberof TradeRecordSym
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TradeRecordSym
     */
    'symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof TradeRecordSym
     */
    'tradSymbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof TradeRecordSym
     */
    'exchange'?: string;
    /**
     * 
     * @type {string}
     * @memberof TradeRecordSym
     */
    'lot'?: string;
    /**
     * 
     * @type {string}
     * @memberof TradeRecordSym
     */
    'instrument'?: string;
    /**
     * 
     * @type {string}
     * @memberof TradeRecordSym
     */
    'companyName'?: string;
    /**
     * 
     * @type {string}
     * @memberof TradeRecordSym
     */
    'expiry'?: string;
    /**
     * 
     * @type {string}
     * @memberof TradeRecordSym
     */
    'dispSymbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof TradeRecordSym
     */
    'asset'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TradeRecordSym
     */
    'empty'?: boolean;
}
/**
 * 
 * @export
 * @interface TradesResponse
 */
export interface TradesResponse {
    /**
     * 
     * @type {string}
     * @memberof TradesResponse
     */
    's'?: TradesResponseSEnum;
    /**
     * 
     * @type {Array<TradeRecord>}
     * @memberof TradesResponse
     */
    'd'?: Array<TradeRecord>;
}

export const TradesResponseSEnum = {
    Ok: 'ok',
    NoData: 'no-data',
    Error: 'error'
} as const;

export type TradesResponseSEnum = typeof TradesResponseSEnum[keyof typeof TradesResponseSEnum];

/**
 * 
 * @export
 * @interface TrailingOrderRecord
 */
export interface TrailingOrderRecord {
    /**
     * 
     * @type {string}
     * @memberof TrailingOrderRecord
     */
    'symId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrailingOrderRecord
     */
    'orderId'?: string;
    /**
     * 
     * @type {string}
     * @memberof TrailingOrderRecord
     */
    'side'?: TrailingOrderRecordSideEnum;
    /**
     * 
     * @type {string}
     * @memberof TrailingOrderRecord
     */
    'type'?: TrailingOrderRecordTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof TrailingOrderRecord
     */
    'product'?: TrailingOrderRecordProductEnum;
    /**
     * 
     * @type {string}
     * @memberof TrailingOrderRecord
     */
    'validity'?: TrailingOrderRecordValidityEnum;
    /**
     * Order quantity
     * @type {number}
     * @memberof TrailingOrderRecord
     */
    'qty'?: number;
    /**
     * 
     * @type {number}
     * @memberof TrailingOrderRecord
     */
    'limitPrice'?: number;
    /**
     * Target order or Profit order price
     * @type {number}
     * @memberof TrailingOrderRecord
     */
    'targetPrice'?: number;
    /**
     * Trailing stop loss price.
     * @type {number}
     * @memberof TrailingOrderRecord
     */
    'trailingStopPrice'?: number;
    /**
     * 
     * @type {string}
     * @memberof TrailingOrderRecord
     */
    'reason'?: string;
    /**
     * Used for pnl calculations. PriceFactor:(General Numerator * Price Numerator)/(General Denominator * Price Denopminator)
     * @type {number}
     * @memberof TrailingOrderRecord
     */
    'priceFactor'?: number;
    /**
     * 
     * @type {number}
     * @memberof TrailingOrderRecord
     */
    'multiplier'?: number;
    /**
     * This is required only for stoploss limit and stoploss market orders
     * @type {number}
     * @memberof TrailingOrderRecord
     */
    'trigPrice'?: number;
    /**
     * 
     * @type {string}
     * @memberof TrailingOrderRecord
     */
    'status'?: string;
}

export const TrailingOrderRecordSideEnum = {
    Buy: 'buy',
    Sell: 'sell'
} as const;

export type TrailingOrderRecordSideEnum = typeof TrailingOrderRecordSideEnum[keyof typeof TrailingOrderRecordSideEnum];
export const TrailingOrderRecordTypeEnum = {
    Limit: 'limit',
    Market: 'market',
    Stoplimit: 'stoplimit',
    Stopmarket: 'stopmarket'
} as const;

export type TrailingOrderRecordTypeEnum = typeof TrailingOrderRecordTypeEnum[keyof typeof TrailingOrderRecordTypeEnum];
export const TrailingOrderRecordProductEnum = {
    Delivery: 'delivery',
    Normal: 'normal',
    Intraday: 'intraday',
    Cover: 'cover',
    Bracket: 'bracket'
} as const;

export type TrailingOrderRecordProductEnum = typeof TrailingOrderRecordProductEnum[keyof typeof TrailingOrderRecordProductEnum];
export const TrailingOrderRecordValidityEnum = {
    Day: 'day',
    Ioc: 'ioc',
    Eos: 'eos',
    Gtc: 'gtc'
} as const;

export type TrailingOrderRecordValidityEnum = typeof TrailingOrderRecordValidityEnum[keyof typeof TrailingOrderRecordValidityEnum];

/**
 * 
 * @export
 * @interface Values
 */
export interface Values {
    /**
     * 
     * @type {string}
     * @memberof Values
     */
    'key'?: string;
    /**
     * 
     * @type {number}
     * @memberof Values
     */
    'value'?: number;
}
/**
 * 
 * @export
 * @interface VolumeShocker
 */
export interface VolumeShocker {
    /**
     * 
     * @type {string}
     * @memberof VolumeShocker
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof VolumeShocker
     */
    'avgVolume'?: string;
}

/**
 * AccountApi - axios parameter creator
 * @export
 */
export const AccountApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * to logout the user and to clear all authorization tokens
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogoutWebResponse: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/account/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http_bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * to fetch the primary user details like name, allowed products and segments
         * @summary Details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDetails: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/account/details`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http_bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountApi - functional programming interface
 * @export
 */
export const AccountApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountApiAxiosParamCreator(configuration)
    return {
        /**
         * to logout the user and to clear all authorization tokens
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLogoutWebResponse(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLogoutWebResponse200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLogoutWebResponse(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AccountApi.getLogoutWebResponse']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * to fetch the primary user details like name, allowed products and segments
         * @summary Details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserDetails(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserDetails200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserDetails(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AccountApi.getUserDetails']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * AccountApi - factory interface
 * @export
 */
export const AccountApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountApiFp(configuration)
    return {
        /**
         * to logout the user and to clear all authorization tokens
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLogoutWebResponse(options?: any): AxiosPromise<GetLogoutWebResponse200Response> {
            return localVarFp.getLogoutWebResponse(options).then((request) => request(axios, basePath));
        },
        /**
         * to fetch the primary user details like name, allowed products and segments
         * @summary Details
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserDetails(options?: any): AxiosPromise<GetUserDetails200Response> {
            return localVarFp.getUserDetails(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountApi - object-oriented interface
 * @export
 * @class AccountApi
 * @extends {BaseAPI}
 */
export class AccountApi extends BaseAPI {
    /**
     * to logout the user and to clear all authorization tokens
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getLogoutWebResponse(options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).getLogoutWebResponse(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * to fetch the primary user details like name, allowed products and segments
     * @summary Details
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountApi
     */
    public getUserDetails(options?: RawAxiosRequestConfig) {
        return AccountApiFp(this.configuration).getUserDetails(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AdvanceOrdersApi - axios parameter creator
 * @export
 */
export const AdvanceOrdersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * to cancel the GTT order
         * @summary Cancel GTT Order
         * @param {string} orderNo Order Number is unique number which will be utilized while modifying and cancelling order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelGTTOrder: async (orderNo: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderNo' is not null or undefined
            assertParamExists('cancelGTTOrder', 'orderNo', orderNo)
            const localVarPath = `/api/oms/cancel-order/gtt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http_bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (orderNo !== undefined) {
                localVarQueryParameter['orderNo'] = orderNo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel A one-cancels-the-other order
         * @summary Cancel OCO Order
         * @param {string} orderNo Order Number is unique number which will be utilized while modifying and cancelling order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOCOOrder: async (orderNo: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderNo' is not null or undefined
            assertParamExists('cancelOCOOrder', 'orderNo', orderNo)
            const localVarPath = `/api/oms/cancel-order/oco`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http_bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (orderNo !== undefined) {
                localVarQueryParameter['orderNo'] = orderNo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * to exit bracket or cover order.
         * @summary Exit Order
         * @param {string} orderId Main leg order id of bracker or cover order should be passed here. It will be received from the field \\\&#39;mainLegOrderId\\\&#39; in orders response
         * @param {ExitOrderProductEnum} product Pass the respective product type bracket or cover here to exit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exitOrder: async (orderId: string, product: ExitOrderProductEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('exitOrder', 'orderId', orderId)
            // verify required parameter 'product' is not null or undefined
            assertParamExists('exitOrder', 'product', product)
            const localVarPath = `/api/oms/exit-order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication http_bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (orderId !== undefined) { 
                localVarFormParams.set('orderId', orderId as any);
            }
    
            if (product !== undefined) { 
                localVarFormParams.set('product', product as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * to modify the bracket order
         * @summary Modify Bracket Order
         * @param {string} symId Unique identifier of the symbol
         * @param {string} orderId Order id of an order which needs modification. This id will be received in orders service
         * @param {number} qty Total order quantity after the modification. ( Filled Qty (if nonzero) + (Modified Qty or Pending Qty)). Example: If the order quantity is 100, out of that 60 is already filled, and if we are modifying the pending qty from 40 to 70 then qty &#x3D;&gt; (60 + 70) &#x3D; 130 should be sent. 
         * @param {ModifyBracketOrderTypeEnum} type Price type of an order
         * @param {number} stopTrigPrice Stop loss leg trigger price. This is the difference of main leg price and the stop loss leg trigger price. If your main leg order price is \\\&#39;2400\\\&#39; and if you want to set the stop loss trigger at \\\&#39;2300\\\&#39; then pass the difference \\\&#39;100\\\&#39; in this field. 
         * @param {number} targetPrice Target leg price. This is the difference of main leg price and the target leg price. If your main leg order price is \\\&#39;2400\\\&#39; and if you want to set the target or profit order price for 2500 then pass the difference \\\&#39;100\\\&#39; in this field
         * @param {number} [limitPrice] Main leg order price. Required only for \\\&#39;limit\\\&#39; and \\\&#39;stoplimit\\\&#39; orders
         * @param {number} [trigPrice] This is applicable only for the main leg order and required only if the order type is \\\&#39;stoplimit\\\&#39;
         * @param {number} [mktProt] This is applicable only for the main leg order and required only if the order type is \\\&#39;market\\\&#39;
         * @param {number} [trailingStopPrice] Trailing stop loss price.
         * @param {ModifyBracketOrderSideEnum} [side] Order side \\\&#39;buy\\\&#39; or \\\&#39;sell\\\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyBracketOrder: async (symId: string, orderId: string, qty: number, type: ModifyBracketOrderTypeEnum, stopTrigPrice: number, targetPrice: number, limitPrice?: number, trigPrice?: number, mktProt?: number, trailingStopPrice?: number, side?: ModifyBracketOrderSideEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symId' is not null or undefined
            assertParamExists('modifyBracketOrder', 'symId', symId)
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('modifyBracketOrder', 'orderId', orderId)
            // verify required parameter 'qty' is not null or undefined
            assertParamExists('modifyBracketOrder', 'qty', qty)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('modifyBracketOrder', 'type', type)
            // verify required parameter 'stopTrigPrice' is not null or undefined
            assertParamExists('modifyBracketOrder', 'stopTrigPrice', stopTrigPrice)
            // verify required parameter 'targetPrice' is not null or undefined
            assertParamExists('modifyBracketOrder', 'targetPrice', targetPrice)
            const localVarPath = `/api/oms/modify-order/bo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication http_bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (symId !== undefined) { 
                localVarFormParams.set('symId', symId as any);
            }
    
            if (orderId !== undefined) { 
                localVarFormParams.set('orderId', orderId as any);
            }
    
            if (qty !== undefined) { 
                localVarFormParams.set('qty', qty as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
            if (limitPrice !== undefined) { 
                localVarFormParams.set('limitPrice', limitPrice as any);
            }
    
            if (trigPrice !== undefined) { 
                localVarFormParams.set('trigPrice', trigPrice as any);
            }
    
            if (mktProt !== undefined) { 
                localVarFormParams.set('mktProt', mktProt as any);
            }
    
            if (stopTrigPrice !== undefined) { 
                localVarFormParams.set('stopTrigPrice', stopTrigPrice as any);
            }
    
            if (targetPrice !== undefined) { 
                localVarFormParams.set('targetPrice', targetPrice as any);
            }
    
            if (trailingStopPrice !== undefined) { 
                localVarFormParams.set('trailingStopPrice', trailingStopPrice as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * to modify the cover order
         * @summary Modify Cover Order
         * @param {string} symId Unique identifier of the symbol
         * @param {string} orderId Order id of an order which needs modification. This id will be received in orders service
         * @param {number} qty Total order quantity after the modification. ( Filled Qty (if nonzero) + (Modified Qty or Pending Qty)). Example: If the order quantity is 100, out of that 60 is already filled, and if we are modifying the pending qty from 40 to 70 then qty &#x3D;&gt; (60 + 70) &#x3D; 130 should be sent. 
         * @param {ModifyCoverOrderTypeEnum} type Price type of an order
         * @param {number} stopTrigPrice Stop loss leg trigger price. This is the difference of main leg price and the stop loss leg trigger price. If your main leg order price is \\\&#39;2400\\\&#39; and if you want to set the stop loss trigger at \\\&#39;2300\\\&#39; then pass the difference \\\&#39;100\\\&#39; in this field. 
         * @param {number} [limitPrice] Main leg order price. Required only for \\\&#39;limit\\\&#39; and \\\&#39;stoplimit\\\&#39; orders
         * @param {number} [trigPrice] This is applicable only for the main leg order and required only if the order type is \\\&#39;stoplimit\\\&#39;
         * @param {number} [mktProt] This is applicable only for the main leg order and required only if the order type is \\\&#39;market\\\&#39;
         * @param {ModifyCoverOrderSideEnum} [side] Order side \\\&#39;buy\\\&#39; or \\\&#39;sell\\\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyCoverOrder: async (symId: string, orderId: string, qty: number, type: ModifyCoverOrderTypeEnum, stopTrigPrice: number, limitPrice?: number, trigPrice?: number, mktProt?: number, side?: ModifyCoverOrderSideEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symId' is not null or undefined
            assertParamExists('modifyCoverOrder', 'symId', symId)
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('modifyCoverOrder', 'orderId', orderId)
            // verify required parameter 'qty' is not null or undefined
            assertParamExists('modifyCoverOrder', 'qty', qty)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('modifyCoverOrder', 'type', type)
            // verify required parameter 'stopTrigPrice' is not null or undefined
            assertParamExists('modifyCoverOrder', 'stopTrigPrice', stopTrigPrice)
            const localVarPath = `/api/oms/modify-order/co`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication http_bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (symId !== undefined) { 
                localVarFormParams.set('symId', symId as any);
            }
    
            if (orderId !== undefined) { 
                localVarFormParams.set('orderId', orderId as any);
            }
    
            if (qty !== undefined) { 
                localVarFormParams.set('qty', qty as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
            if (limitPrice !== undefined) { 
                localVarFormParams.set('limitPrice', limitPrice as any);
            }
    
            if (trigPrice !== undefined) { 
                localVarFormParams.set('trigPrice', trigPrice as any);
            }
    
            if (mktProt !== undefined) { 
                localVarFormParams.set('mktProt', mktProt as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (stopTrigPrice !== undefined) { 
                localVarFormParams.set('stopTrigPrice', stopTrigPrice as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify good till triggered order
         * @summary Modify GTT Order
         * @param {string} orderId Order Number is unique number which will be utilized while modifying and cancelling order
         * @param {string} symId Unique identifier of the symbol
         * @param {ModifyGTTOrderSideEnum} side Order id of an order. This will be received in orders response
         * @param {ModifyGTTOrderTypeEnum} type Price type of an order
         * @param {ModifyGTTOrderProductEnum} product Product type of an order. \\\&#39;delivery\\\&#39; is applicable for equities. \\\&#39;normal\\\&#39; is applicable for derivatives. \\\&#39;intraday\\\&#39; is applicable for both equity and derivatives
         * @param {number} trigPricePer Price difference from the LTP in percentage, calculated using the formula: (trigPrice - LTP) / LTP × 100. This value can be positive or negative, depending on whether the trigPrice is above or below the LTP.
         * @param {number} trigPrice Trigger price with respect to LTP
         * @param {number} qty No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.
         * @param {number} [limitPrice] This is required only for limit and stop limit orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyGTTOrder: async (orderId: string, symId: string, side: ModifyGTTOrderSideEnum, type: ModifyGTTOrderTypeEnum, product: ModifyGTTOrderProductEnum, trigPricePer: number, trigPrice: number, qty: number, limitPrice?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('modifyGTTOrder', 'orderId', orderId)
            // verify required parameter 'symId' is not null or undefined
            assertParamExists('modifyGTTOrder', 'symId', symId)
            // verify required parameter 'side' is not null or undefined
            assertParamExists('modifyGTTOrder', 'side', side)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('modifyGTTOrder', 'type', type)
            // verify required parameter 'product' is not null or undefined
            assertParamExists('modifyGTTOrder', 'product', product)
            // verify required parameter 'trigPricePer' is not null or undefined
            assertParamExists('modifyGTTOrder', 'trigPricePer', trigPricePer)
            // verify required parameter 'trigPrice' is not null or undefined
            assertParamExists('modifyGTTOrder', 'trigPrice', trigPrice)
            // verify required parameter 'qty' is not null or undefined
            assertParamExists('modifyGTTOrder', 'qty', qty)
            const localVarPath = `/api/oms/modify-order/gtt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication http_bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (orderId !== undefined) { 
                localVarFormParams.set('orderId', orderId as any);
            }
    
            if (symId !== undefined) { 
                localVarFormParams.set('symId', symId as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
            if (product !== undefined) { 
                localVarFormParams.set('product', product as any);
            }
    
            if (trigPricePer !== undefined) { 
                localVarFormParams.set('trigPricePer', trigPricePer as any);
            }
    
            if (trigPrice !== undefined) { 
                localVarFormParams.set('trigPrice', trigPrice as any);
            }
    
            if (qty !== undefined) { 
                localVarFormParams.set('qty', qty as any);
            }
    
            if (limitPrice !== undefined) { 
                localVarFormParams.set('limitPrice', limitPrice as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Modify one-cancels-the-other order
         * @summary Modify OCO Order
         * @param {string} orderId Order Number is unique number which will be utilized while modifying and cancelling order
         * @param {string} symId Unique identifier of the symbol
         * @param {ModifyOCOOrderSideEnum} side Order id of an order. This will be received in orders response
         * @param {ModifyOCOOrderStopLossTypeEnum} stopLossType Price type of an order
         * @param {ModifyOCOOrderStopLossProductEnum} stopLossProduct Product type of an order. \\\&#39;delivery\\\&#39; is applicable for equities. \\\&#39;normal\\\&#39; is applicable for derivatives. \\\&#39;intraday\\\&#39; is applicable for both equity and derivatives
         * @param {number} stopTrigPrice Stoploss trigger price
         * @param {number} stopQty No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.
         * @param {ModifyOCOOrderTargetTypeEnum} targetType Price type of an order
         * @param {ModifyOCOOrderTargetProductEnum} targetProduct Product type of an order. \\\&#39;delivery\\\&#39; is applicable for equities. \\\&#39;normal\\\&#39; is applicable for derivatives. \\\&#39;intraday\\\&#39; is applicable for both equity and derivatives
         * @param {number} targetTrigPrice Target trigger price
         * @param {number} targetQty No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.
         * @param {number} [stopPrice] This is required only for limit and stop limit orders
         * @param {number} [targetPrice] This is required only for limit and stop limit orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyOCOOrder: async (orderId: string, symId: string, side: ModifyOCOOrderSideEnum, stopLossType: ModifyOCOOrderStopLossTypeEnum, stopLossProduct: ModifyOCOOrderStopLossProductEnum, stopTrigPrice: number, stopQty: number, targetType: ModifyOCOOrderTargetTypeEnum, targetProduct: ModifyOCOOrderTargetProductEnum, targetTrigPrice: number, targetQty: number, stopPrice?: number, targetPrice?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('modifyOCOOrder', 'orderId', orderId)
            // verify required parameter 'symId' is not null or undefined
            assertParamExists('modifyOCOOrder', 'symId', symId)
            // verify required parameter 'side' is not null or undefined
            assertParamExists('modifyOCOOrder', 'side', side)
            // verify required parameter 'stopLossType' is not null or undefined
            assertParamExists('modifyOCOOrder', 'stopLossType', stopLossType)
            // verify required parameter 'stopLossProduct' is not null or undefined
            assertParamExists('modifyOCOOrder', 'stopLossProduct', stopLossProduct)
            // verify required parameter 'stopTrigPrice' is not null or undefined
            assertParamExists('modifyOCOOrder', 'stopTrigPrice', stopTrigPrice)
            // verify required parameter 'stopQty' is not null or undefined
            assertParamExists('modifyOCOOrder', 'stopQty', stopQty)
            // verify required parameter 'targetType' is not null or undefined
            assertParamExists('modifyOCOOrder', 'targetType', targetType)
            // verify required parameter 'targetProduct' is not null or undefined
            assertParamExists('modifyOCOOrder', 'targetProduct', targetProduct)
            // verify required parameter 'targetTrigPrice' is not null or undefined
            assertParamExists('modifyOCOOrder', 'targetTrigPrice', targetTrigPrice)
            // verify required parameter 'targetQty' is not null or undefined
            assertParamExists('modifyOCOOrder', 'targetQty', targetQty)
            const localVarPath = `/api/oms/modify-order/oco`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication http_bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (orderId !== undefined) { 
                localVarFormParams.set('orderId', orderId as any);
            }
    
            if (symId !== undefined) { 
                localVarFormParams.set('symId', symId as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (stopLossType !== undefined) { 
                localVarFormParams.set('stopLossType', stopLossType as any);
            }
    
            if (stopLossProduct !== undefined) { 
                localVarFormParams.set('stopLossProduct', stopLossProduct as any);
            }
    
            if (stopTrigPrice !== undefined) { 
                localVarFormParams.set('stopTrigPrice', stopTrigPrice as any);
            }
    
            if (stopQty !== undefined) { 
                localVarFormParams.set('stopQty', stopQty as any);
            }
    
            if (stopPrice !== undefined) { 
                localVarFormParams.set('stopPrice', stopPrice as any);
            }
    
            if (targetType !== undefined) { 
                localVarFormParams.set('targetType', targetType as any);
            }
    
            if (targetProduct !== undefined) { 
                localVarFormParams.set('targetProduct', targetProduct as any);
            }
    
            if (targetTrigPrice !== undefined) { 
                localVarFormParams.set('targetTrigPrice', targetTrigPrice as any);
            }
    
            if (targetQty !== undefined) { 
                localVarFormParams.set('targetQty', targetQty as any);
            }
    
            if (targetPrice !== undefined) { 
                localVarFormParams.set('targetPrice', targetPrice as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * to get the list of pending gtt, oco orders orders
         * @summary GTT OrderBook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pendingGTTOrders: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/oms/orders/gtt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http_bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * to place the bracket order
         * @summary Place Bracket Order
         * @param {string} symId Unique identifier of the symbol
         * @param {number} qty No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.
         * @param {PlaceBracketOrderSideEnum} side Order side \\\&#39;buy\\\&#39; or \\\&#39;sell\\\&#39;
         * @param {PlaceBracketOrderTypeEnum} type Price type of an order
         * @param {number} stopTrigPrice Stop loss leg trigger price. This is the difference of main leg price and the stop loss leg trigger price. If your main leg order price is \\\&#39;2400\\\&#39; and if you want to set the stop loss trigger at \\\&#39;2300\\\&#39; then pass the difference \\\&#39;100\\\&#39; in this field. 
         * @param {number} targetPrice Target leg price. This is the difference of main leg price and the target leg price. If your main leg order price is \\\&#39;2400\\\&#39; and if you want to set the target or profit order price for 2500 then pass the difference \\\&#39;100\\\&#39; in this field
         * @param {number} [limitPrice] Main leg order price. Required only for \\\&#39;limit\\\&#39; and \\\&#39;stoplimit\\\&#39; orders
         * @param {number} [trigPrice] This is applicable only for the main leg order and required only if the order type is \\\&#39;stoplimit\\\&#39;
         * @param {number} [mktProt] This is applicable only for the main leg order and required only if the order type is \\\&#39;market\\\&#39;
         * @param {number} [trailingStopPrice] Trailing stop loss price.
         * @param {string} [remarks] Any tag or message to track in orderbook.Allowed length upto 10 Characters. Please note remarks more than 10 characters will be stripped out.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeBracketOrder: async (symId: string, qty: number, side: PlaceBracketOrderSideEnum, type: PlaceBracketOrderTypeEnum, stopTrigPrice: number, targetPrice: number, limitPrice?: number, trigPrice?: number, mktProt?: number, trailingStopPrice?: number, remarks?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symId' is not null or undefined
            assertParamExists('placeBracketOrder', 'symId', symId)
            // verify required parameter 'qty' is not null or undefined
            assertParamExists('placeBracketOrder', 'qty', qty)
            // verify required parameter 'side' is not null or undefined
            assertParamExists('placeBracketOrder', 'side', side)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('placeBracketOrder', 'type', type)
            // verify required parameter 'stopTrigPrice' is not null or undefined
            assertParamExists('placeBracketOrder', 'stopTrigPrice', stopTrigPrice)
            // verify required parameter 'targetPrice' is not null or undefined
            assertParamExists('placeBracketOrder', 'targetPrice', targetPrice)
            const localVarPath = `/api/oms/place-order/bo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication http_bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (symId !== undefined) { 
                localVarFormParams.set('symId', symId as any);
            }
    
            if (qty !== undefined) { 
                localVarFormParams.set('qty', qty as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
            if (limitPrice !== undefined) { 
                localVarFormParams.set('limitPrice', limitPrice as any);
            }
    
            if (trigPrice !== undefined) { 
                localVarFormParams.set('trigPrice', trigPrice as any);
            }
    
            if (mktProt !== undefined) { 
                localVarFormParams.set('mktProt', mktProt as any);
            }
    
            if (stopTrigPrice !== undefined) { 
                localVarFormParams.set('stopTrigPrice', stopTrigPrice as any);
            }
    
            if (targetPrice !== undefined) { 
                localVarFormParams.set('targetPrice', targetPrice as any);
            }
    
            if (trailingStopPrice !== undefined) { 
                localVarFormParams.set('trailingStopPrice', trailingStopPrice as any);
            }
    
            if (remarks !== undefined) { 
                localVarFormParams.set('remarks', remarks as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * to place the cover order
         * @summary Place Cover Order
         * @param {string} symId Unique identifier of the symbol
         * @param {number} qty No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.
         * @param {PlaceCoverOrderSideEnum} side Order side \\\&#39;buy\\\&#39; or \\\&#39;sell\\\&#39;
         * @param {PlaceCoverOrderTypeEnum} type Price type of an order
         * @param {number} stopTrigPrice Stop loss leg trigger price. This is the difference of main leg price and the stop loss leg trigger price. If your main leg order price is \\\&#39;2400\\\&#39; and if you want to set the stop loss trigger at \\\&#39;2300\\\&#39; then pass the difference \\\&#39;100\\\&#39; in this field. 
         * @param {number} [limitPrice] Main leg order price. Required only for \\\&#39;limit\\\&#39; and \\\&#39;stoplimit\\\&#39; orders
         * @param {number} [trigPrice] This is applicable only for the main leg order and required only if the order type is \\\&#39;stoplimit\\\&#39;
         * @param {number} [mktProt] This is applicable only for the main leg order and required only if the order type is \\\&#39;market\\\&#39;
         * @param {string} [remarks] Any tag or message to track in orderbook.Allowed length upto 10 Characters. Please note remarks more than 10 characters will be stripped out.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeCoverOrder: async (symId: string, qty: number, side: PlaceCoverOrderSideEnum, type: PlaceCoverOrderTypeEnum, stopTrigPrice: number, limitPrice?: number, trigPrice?: number, mktProt?: number, remarks?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symId' is not null or undefined
            assertParamExists('placeCoverOrder', 'symId', symId)
            // verify required parameter 'qty' is not null or undefined
            assertParamExists('placeCoverOrder', 'qty', qty)
            // verify required parameter 'side' is not null or undefined
            assertParamExists('placeCoverOrder', 'side', side)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('placeCoverOrder', 'type', type)
            // verify required parameter 'stopTrigPrice' is not null or undefined
            assertParamExists('placeCoverOrder', 'stopTrigPrice', stopTrigPrice)
            const localVarPath = `/api/oms/place-order/co`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication http_bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (symId !== undefined) { 
                localVarFormParams.set('symId', symId as any);
            }
    
            if (qty !== undefined) { 
                localVarFormParams.set('qty', qty as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
            if (limitPrice !== undefined) { 
                localVarFormParams.set('limitPrice', limitPrice as any);
            }
    
            if (trigPrice !== undefined) { 
                localVarFormParams.set('trigPrice', trigPrice as any);
            }
    
            if (mktProt !== undefined) { 
                localVarFormParams.set('mktProt', mktProt as any);
            }
    
            if (stopTrigPrice !== undefined) { 
                localVarFormParams.set('stopTrigPrice', stopTrigPrice as any);
            }
    
            if (remarks !== undefined) { 
                localVarFormParams.set('remarks', remarks as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Place good till triggered order
         * @summary Place GTT Order
         * @param {string} symId Unique identifier of the symbol
         * @param {PlaceGTTOrderTypeEnum} type Price type of an order
         * @param {PlaceGTTOrderSideEnum} side Order id of an order. This will be received in orders response
         * @param {PlaceGTTOrderProductEnum} product Product type of an order. \\\&#39;delivery\\\&#39; is applicable for equities. \\\&#39;normal\\\&#39; is applicable for derivatives. \\\&#39;intraday\\\&#39; is applicable for both equity and derivatives
         * @param {number} trigPricePer Price difference from the LTP in percentage, calculated using the formula: (trigPrice - LTP) / LTP × 100. This value can be positive or negative, depending on whether the trigPrice is above or below the LTP.
         * @param {number} trigPrice Trigger price with respect to LTP
         * @param {number} qty No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.
         * @param {number} [limitPrice] This is required only for limit and stop limit orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeGTTOrder: async (symId: string, type: PlaceGTTOrderTypeEnum, side: PlaceGTTOrderSideEnum, product: PlaceGTTOrderProductEnum, trigPricePer: number, trigPrice: number, qty: number, limitPrice?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symId' is not null or undefined
            assertParamExists('placeGTTOrder', 'symId', symId)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('placeGTTOrder', 'type', type)
            // verify required parameter 'side' is not null or undefined
            assertParamExists('placeGTTOrder', 'side', side)
            // verify required parameter 'product' is not null or undefined
            assertParamExists('placeGTTOrder', 'product', product)
            // verify required parameter 'trigPricePer' is not null or undefined
            assertParamExists('placeGTTOrder', 'trigPricePer', trigPricePer)
            // verify required parameter 'trigPrice' is not null or undefined
            assertParamExists('placeGTTOrder', 'trigPrice', trigPrice)
            // verify required parameter 'qty' is not null or undefined
            assertParamExists('placeGTTOrder', 'qty', qty)
            const localVarPath = `/api/oms/place-order/gtt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication http_bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (symId !== undefined) { 
                localVarFormParams.set('symId', symId as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (product !== undefined) { 
                localVarFormParams.set('product', product as any);
            }
    
            if (trigPricePer !== undefined) { 
                localVarFormParams.set('trigPricePer', trigPricePer as any);
            }
    
            if (trigPrice !== undefined) { 
                localVarFormParams.set('trigPrice', trigPrice as any);
            }
    
            if (qty !== undefined) { 
                localVarFormParams.set('qty', qty as any);
            }
    
            if (limitPrice !== undefined) { 
                localVarFormParams.set('limitPrice', limitPrice as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Place A one-cancels-the-other order
         * @summary Place OCO Order
         * @param {string} symId Unique identifier of the symbol
         * @param {PlaceOCOOrderSideEnum} side Order id of an order. This will be received in orders response
         * @param {PlaceOCOOrderStopLossTypeEnum} stopLossType Price type of an order
         * @param {PlaceOCOOrderStopLossProductEnum} stopLossProduct Product type of an order. \\\&#39;delivery\\\&#39; is applicable for equities. \\\&#39;normal\\\&#39; is applicable for derivatives. \\\&#39;intraday\\\&#39; is applicable for both equity and derivatives
         * @param {number} stopTrigPrice Trigger price with respect to LTP
         * @param {number} stopQty No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.
         * @param {PlaceOCOOrderTargetTypeEnum} targetType Price type of an order
         * @param {PlaceOCOOrderTargetProductEnum} targetProduct Product type of an order. \\\&#39;delivery\\\&#39; is applicable for equities. \\\&#39;normal\\\&#39; is applicable for derivatives. \\\&#39;intraday\\\&#39; is applicable for both equity and derivatives
         * @param {number} targetTrigPrice Trigger price with respect to LTP
         * @param {number} targetQty No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.
         * @param {number} [stopPrice] This is required only for limit and stop limit orders
         * @param {number} [targetPrice] This is required only for limit and stop limit orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeOCOOrder: async (symId: string, side: PlaceOCOOrderSideEnum, stopLossType: PlaceOCOOrderStopLossTypeEnum, stopLossProduct: PlaceOCOOrderStopLossProductEnum, stopTrigPrice: number, stopQty: number, targetType: PlaceOCOOrderTargetTypeEnum, targetProduct: PlaceOCOOrderTargetProductEnum, targetTrigPrice: number, targetQty: number, stopPrice?: number, targetPrice?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symId' is not null or undefined
            assertParamExists('placeOCOOrder', 'symId', symId)
            // verify required parameter 'side' is not null or undefined
            assertParamExists('placeOCOOrder', 'side', side)
            // verify required parameter 'stopLossType' is not null or undefined
            assertParamExists('placeOCOOrder', 'stopLossType', stopLossType)
            // verify required parameter 'stopLossProduct' is not null or undefined
            assertParamExists('placeOCOOrder', 'stopLossProduct', stopLossProduct)
            // verify required parameter 'stopTrigPrice' is not null or undefined
            assertParamExists('placeOCOOrder', 'stopTrigPrice', stopTrigPrice)
            // verify required parameter 'stopQty' is not null or undefined
            assertParamExists('placeOCOOrder', 'stopQty', stopQty)
            // verify required parameter 'targetType' is not null or undefined
            assertParamExists('placeOCOOrder', 'targetType', targetType)
            // verify required parameter 'targetProduct' is not null or undefined
            assertParamExists('placeOCOOrder', 'targetProduct', targetProduct)
            // verify required parameter 'targetTrigPrice' is not null or undefined
            assertParamExists('placeOCOOrder', 'targetTrigPrice', targetTrigPrice)
            // verify required parameter 'targetQty' is not null or undefined
            assertParamExists('placeOCOOrder', 'targetQty', targetQty)
            const localVarPath = `/api/oms/place-order/oco`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication http_bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (symId !== undefined) { 
                localVarFormParams.set('symId', symId as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (stopLossType !== undefined) { 
                localVarFormParams.set('stopLossType', stopLossType as any);
            }
    
            if (stopLossProduct !== undefined) { 
                localVarFormParams.set('stopLossProduct', stopLossProduct as any);
            }
    
            if (stopTrigPrice !== undefined) { 
                localVarFormParams.set('stopTrigPrice', stopTrigPrice as any);
            }
    
            if (stopQty !== undefined) { 
                localVarFormParams.set('stopQty', stopQty as any);
            }
    
            if (stopPrice !== undefined) { 
                localVarFormParams.set('stopPrice', stopPrice as any);
            }
    
            if (targetType !== undefined) { 
                localVarFormParams.set('targetType', targetType as any);
            }
    
            if (targetProduct !== undefined) { 
                localVarFormParams.set('targetProduct', targetProduct as any);
            }
    
            if (targetTrigPrice !== undefined) { 
                localVarFormParams.set('targetTrigPrice', targetTrigPrice as any);
            }
    
            if (targetQty !== undefined) { 
                localVarFormParams.set('targetQty', targetQty as any);
            }
    
            if (targetPrice !== undefined) { 
                localVarFormParams.set('targetPrice', targetPrice as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdvanceOrdersApi - functional programming interface
 * @export
 */
export const AdvanceOrdersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdvanceOrdersApiAxiosParamCreator(configuration)
    return {
        /**
         * to cancel the GTT order
         * @summary Cancel GTT Order
         * @param {string} orderNo Order Number is unique number which will be utilized while modifying and cancelling order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelGTTOrder(orderNo: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CancelGTTOrder200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelGTTOrder(orderNo, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AdvanceOrdersApi.cancelGTTOrder']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Cancel A one-cancels-the-other order
         * @summary Cancel OCO Order
         * @param {string} orderNo Order Number is unique number which will be utilized while modifying and cancelling order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelOCOOrder(orderNo: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CancelOCOOrder200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelOCOOrder(orderNo, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AdvanceOrdersApi.cancelOCOOrder']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * to exit bracket or cover order.
         * @summary Exit Order
         * @param {string} orderId Main leg order id of bracker or cover order should be passed here. It will be received from the field \\\&#39;mainLegOrderId\\\&#39; in orders response
         * @param {ExitOrderProductEnum} product Pass the respective product type bracket or cover here to exit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async exitOrder(orderId: string, product: ExitOrderProductEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExitOrder200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.exitOrder(orderId, product, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AdvanceOrdersApi.exitOrder']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * to modify the bracket order
         * @summary Modify Bracket Order
         * @param {string} symId Unique identifier of the symbol
         * @param {string} orderId Order id of an order which needs modification. This id will be received in orders service
         * @param {number} qty Total order quantity after the modification. ( Filled Qty (if nonzero) + (Modified Qty or Pending Qty)). Example: If the order quantity is 100, out of that 60 is already filled, and if we are modifying the pending qty from 40 to 70 then qty &#x3D;&gt; (60 + 70) &#x3D; 130 should be sent. 
         * @param {ModifyBracketOrderTypeEnum} type Price type of an order
         * @param {number} stopTrigPrice Stop loss leg trigger price. This is the difference of main leg price and the stop loss leg trigger price. If your main leg order price is \\\&#39;2400\\\&#39; and if you want to set the stop loss trigger at \\\&#39;2300\\\&#39; then pass the difference \\\&#39;100\\\&#39; in this field. 
         * @param {number} targetPrice Target leg price. This is the difference of main leg price and the target leg price. If your main leg order price is \\\&#39;2400\\\&#39; and if you want to set the target or profit order price for 2500 then pass the difference \\\&#39;100\\\&#39; in this field
         * @param {number} [limitPrice] Main leg order price. Required only for \\\&#39;limit\\\&#39; and \\\&#39;stoplimit\\\&#39; orders
         * @param {number} [trigPrice] This is applicable only for the main leg order and required only if the order type is \\\&#39;stoplimit\\\&#39;
         * @param {number} [mktProt] This is applicable only for the main leg order and required only if the order type is \\\&#39;market\\\&#39;
         * @param {number} [trailingStopPrice] Trailing stop loss price.
         * @param {ModifyBracketOrderSideEnum} [side] Order side \\\&#39;buy\\\&#39; or \\\&#39;sell\\\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyBracketOrder(symId: string, orderId: string, qty: number, type: ModifyBracketOrderTypeEnum, stopTrigPrice: number, targetPrice: number, limitPrice?: number, trigPrice?: number, mktProt?: number, trailingStopPrice?: number, side?: ModifyBracketOrderSideEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModifyOrder200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyBracketOrder(symId, orderId, qty, type, stopTrigPrice, targetPrice, limitPrice, trigPrice, mktProt, trailingStopPrice, side, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AdvanceOrdersApi.modifyBracketOrder']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * to modify the cover order
         * @summary Modify Cover Order
         * @param {string} symId Unique identifier of the symbol
         * @param {string} orderId Order id of an order which needs modification. This id will be received in orders service
         * @param {number} qty Total order quantity after the modification. ( Filled Qty (if nonzero) + (Modified Qty or Pending Qty)). Example: If the order quantity is 100, out of that 60 is already filled, and if we are modifying the pending qty from 40 to 70 then qty &#x3D;&gt; (60 + 70) &#x3D; 130 should be sent. 
         * @param {ModifyCoverOrderTypeEnum} type Price type of an order
         * @param {number} stopTrigPrice Stop loss leg trigger price. This is the difference of main leg price and the stop loss leg trigger price. If your main leg order price is \\\&#39;2400\\\&#39; and if you want to set the stop loss trigger at \\\&#39;2300\\\&#39; then pass the difference \\\&#39;100\\\&#39; in this field. 
         * @param {number} [limitPrice] Main leg order price. Required only for \\\&#39;limit\\\&#39; and \\\&#39;stoplimit\\\&#39; orders
         * @param {number} [trigPrice] This is applicable only for the main leg order and required only if the order type is \\\&#39;stoplimit\\\&#39;
         * @param {number} [mktProt] This is applicable only for the main leg order and required only if the order type is \\\&#39;market\\\&#39;
         * @param {ModifyCoverOrderSideEnum} [side] Order side \\\&#39;buy\\\&#39; or \\\&#39;sell\\\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyCoverOrder(symId: string, orderId: string, qty: number, type: ModifyCoverOrderTypeEnum, stopTrigPrice: number, limitPrice?: number, trigPrice?: number, mktProt?: number, side?: ModifyCoverOrderSideEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModifyOrder200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyCoverOrder(symId, orderId, qty, type, stopTrigPrice, limitPrice, trigPrice, mktProt, side, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AdvanceOrdersApi.modifyCoverOrder']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Modify good till triggered order
         * @summary Modify GTT Order
         * @param {string} orderId Order Number is unique number which will be utilized while modifying and cancelling order
         * @param {string} symId Unique identifier of the symbol
         * @param {ModifyGTTOrderSideEnum} side Order id of an order. This will be received in orders response
         * @param {ModifyGTTOrderTypeEnum} type Price type of an order
         * @param {ModifyGTTOrderProductEnum} product Product type of an order. \\\&#39;delivery\\\&#39; is applicable for equities. \\\&#39;normal\\\&#39; is applicable for derivatives. \\\&#39;intraday\\\&#39; is applicable for both equity and derivatives
         * @param {number} trigPricePer Price difference from the LTP in percentage, calculated using the formula: (trigPrice - LTP) / LTP × 100. This value can be positive or negative, depending on whether the trigPrice is above or below the LTP.
         * @param {number} trigPrice Trigger price with respect to LTP
         * @param {number} qty No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.
         * @param {number} [limitPrice] This is required only for limit and stop limit orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyGTTOrder(orderId: string, symId: string, side: ModifyGTTOrderSideEnum, type: ModifyGTTOrderTypeEnum, product: ModifyGTTOrderProductEnum, trigPricePer: number, trigPrice: number, qty: number, limitPrice?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModifyGTTOrder200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyGTTOrder(orderId, symId, side, type, product, trigPricePer, trigPrice, qty, limitPrice, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AdvanceOrdersApi.modifyGTTOrder']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Modify one-cancels-the-other order
         * @summary Modify OCO Order
         * @param {string} orderId Order Number is unique number which will be utilized while modifying and cancelling order
         * @param {string} symId Unique identifier of the symbol
         * @param {ModifyOCOOrderSideEnum} side Order id of an order. This will be received in orders response
         * @param {ModifyOCOOrderStopLossTypeEnum} stopLossType Price type of an order
         * @param {ModifyOCOOrderStopLossProductEnum} stopLossProduct Product type of an order. \\\&#39;delivery\\\&#39; is applicable for equities. \\\&#39;normal\\\&#39; is applicable for derivatives. \\\&#39;intraday\\\&#39; is applicable for both equity and derivatives
         * @param {number} stopTrigPrice Stoploss trigger price
         * @param {number} stopQty No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.
         * @param {ModifyOCOOrderTargetTypeEnum} targetType Price type of an order
         * @param {ModifyOCOOrderTargetProductEnum} targetProduct Product type of an order. \\\&#39;delivery\\\&#39; is applicable for equities. \\\&#39;normal\\\&#39; is applicable for derivatives. \\\&#39;intraday\\\&#39; is applicable for both equity and derivatives
         * @param {number} targetTrigPrice Target trigger price
         * @param {number} targetQty No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.
         * @param {number} [stopPrice] This is required only for limit and stop limit orders
         * @param {number} [targetPrice] This is required only for limit and stop limit orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyOCOOrder(orderId: string, symId: string, side: ModifyOCOOrderSideEnum, stopLossType: ModifyOCOOrderStopLossTypeEnum, stopLossProduct: ModifyOCOOrderStopLossProductEnum, stopTrigPrice: number, stopQty: number, targetType: ModifyOCOOrderTargetTypeEnum, targetProduct: ModifyOCOOrderTargetProductEnum, targetTrigPrice: number, targetQty: number, stopPrice?: number, targetPrice?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModifyOCOOrder200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyOCOOrder(orderId, symId, side, stopLossType, stopLossProduct, stopTrigPrice, stopQty, targetType, targetProduct, targetTrigPrice, targetQty, stopPrice, targetPrice, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AdvanceOrdersApi.modifyOCOOrder']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * to get the list of pending gtt, oco orders orders
         * @summary GTT OrderBook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pendingGTTOrders(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PendingGTTOrders200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pendingGTTOrders(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AdvanceOrdersApi.pendingGTTOrders']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * to place the bracket order
         * @summary Place Bracket Order
         * @param {string} symId Unique identifier of the symbol
         * @param {number} qty No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.
         * @param {PlaceBracketOrderSideEnum} side Order side \\\&#39;buy\\\&#39; or \\\&#39;sell\\\&#39;
         * @param {PlaceBracketOrderTypeEnum} type Price type of an order
         * @param {number} stopTrigPrice Stop loss leg trigger price. This is the difference of main leg price and the stop loss leg trigger price. If your main leg order price is \\\&#39;2400\\\&#39; and if you want to set the stop loss trigger at \\\&#39;2300\\\&#39; then pass the difference \\\&#39;100\\\&#39; in this field. 
         * @param {number} targetPrice Target leg price. This is the difference of main leg price and the target leg price. If your main leg order price is \\\&#39;2400\\\&#39; and if you want to set the target or profit order price for 2500 then pass the difference \\\&#39;100\\\&#39; in this field
         * @param {number} [limitPrice] Main leg order price. Required only for \\\&#39;limit\\\&#39; and \\\&#39;stoplimit\\\&#39; orders
         * @param {number} [trigPrice] This is applicable only for the main leg order and required only if the order type is \\\&#39;stoplimit\\\&#39;
         * @param {number} [mktProt] This is applicable only for the main leg order and required only if the order type is \\\&#39;market\\\&#39;
         * @param {number} [trailingStopPrice] Trailing stop loss price.
         * @param {string} [remarks] Any tag or message to track in orderbook.Allowed length upto 10 Characters. Please note remarks more than 10 characters will be stripped out.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placeBracketOrder(symId: string, qty: number, side: PlaceBracketOrderSideEnum, type: PlaceBracketOrderTypeEnum, stopTrigPrice: number, targetPrice: number, limitPrice?: number, trigPrice?: number, mktProt?: number, trailingStopPrice?: number, remarks?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaceBracketOrder200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placeBracketOrder(symId, qty, side, type, stopTrigPrice, targetPrice, limitPrice, trigPrice, mktProt, trailingStopPrice, remarks, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AdvanceOrdersApi.placeBracketOrder']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * to place the cover order
         * @summary Place Cover Order
         * @param {string} symId Unique identifier of the symbol
         * @param {number} qty No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.
         * @param {PlaceCoverOrderSideEnum} side Order side \\\&#39;buy\\\&#39; or \\\&#39;sell\\\&#39;
         * @param {PlaceCoverOrderTypeEnum} type Price type of an order
         * @param {number} stopTrigPrice Stop loss leg trigger price. This is the difference of main leg price and the stop loss leg trigger price. If your main leg order price is \\\&#39;2400\\\&#39; and if you want to set the stop loss trigger at \\\&#39;2300\\\&#39; then pass the difference \\\&#39;100\\\&#39; in this field. 
         * @param {number} [limitPrice] Main leg order price. Required only for \\\&#39;limit\\\&#39; and \\\&#39;stoplimit\\\&#39; orders
         * @param {number} [trigPrice] This is applicable only for the main leg order and required only if the order type is \\\&#39;stoplimit\\\&#39;
         * @param {number} [mktProt] This is applicable only for the main leg order and required only if the order type is \\\&#39;market\\\&#39;
         * @param {string} [remarks] Any tag or message to track in orderbook.Allowed length upto 10 Characters. Please note remarks more than 10 characters will be stripped out.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placeCoverOrder(symId: string, qty: number, side: PlaceCoverOrderSideEnum, type: PlaceCoverOrderTypeEnum, stopTrigPrice: number, limitPrice?: number, trigPrice?: number, mktProt?: number, remarks?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaceBracketOrder200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placeCoverOrder(symId, qty, side, type, stopTrigPrice, limitPrice, trigPrice, mktProt, remarks, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AdvanceOrdersApi.placeCoverOrder']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Place good till triggered order
         * @summary Place GTT Order
         * @param {string} symId Unique identifier of the symbol
         * @param {PlaceGTTOrderTypeEnum} type Price type of an order
         * @param {PlaceGTTOrderSideEnum} side Order id of an order. This will be received in orders response
         * @param {PlaceGTTOrderProductEnum} product Product type of an order. \\\&#39;delivery\\\&#39; is applicable for equities. \\\&#39;normal\\\&#39; is applicable for derivatives. \\\&#39;intraday\\\&#39; is applicable for both equity and derivatives
         * @param {number} trigPricePer Price difference from the LTP in percentage, calculated using the formula: (trigPrice - LTP) / LTP × 100. This value can be positive or negative, depending on whether the trigPrice is above or below the LTP.
         * @param {number} trigPrice Trigger price with respect to LTP
         * @param {number} qty No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.
         * @param {number} [limitPrice] This is required only for limit and stop limit orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placeGTTOrder(symId: string, type: PlaceGTTOrderTypeEnum, side: PlaceGTTOrderSideEnum, product: PlaceGTTOrderProductEnum, trigPricePer: number, trigPrice: number, qty: number, limitPrice?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaceGTTOrder200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placeGTTOrder(symId, type, side, product, trigPricePer, trigPrice, qty, limitPrice, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AdvanceOrdersApi.placeGTTOrder']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Place A one-cancels-the-other order
         * @summary Place OCO Order
         * @param {string} symId Unique identifier of the symbol
         * @param {PlaceOCOOrderSideEnum} side Order id of an order. This will be received in orders response
         * @param {PlaceOCOOrderStopLossTypeEnum} stopLossType Price type of an order
         * @param {PlaceOCOOrderStopLossProductEnum} stopLossProduct Product type of an order. \\\&#39;delivery\\\&#39; is applicable for equities. \\\&#39;normal\\\&#39; is applicable for derivatives. \\\&#39;intraday\\\&#39; is applicable for both equity and derivatives
         * @param {number} stopTrigPrice Trigger price with respect to LTP
         * @param {number} stopQty No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.
         * @param {PlaceOCOOrderTargetTypeEnum} targetType Price type of an order
         * @param {PlaceOCOOrderTargetProductEnum} targetProduct Product type of an order. \\\&#39;delivery\\\&#39; is applicable for equities. \\\&#39;normal\\\&#39; is applicable for derivatives. \\\&#39;intraday\\\&#39; is applicable for both equity and derivatives
         * @param {number} targetTrigPrice Trigger price with respect to LTP
         * @param {number} targetQty No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.
         * @param {number} [stopPrice] This is required only for limit and stop limit orders
         * @param {number} [targetPrice] This is required only for limit and stop limit orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placeOCOOrder(symId: string, side: PlaceOCOOrderSideEnum, stopLossType: PlaceOCOOrderStopLossTypeEnum, stopLossProduct: PlaceOCOOrderStopLossProductEnum, stopTrigPrice: number, stopQty: number, targetType: PlaceOCOOrderTargetTypeEnum, targetProduct: PlaceOCOOrderTargetProductEnum, targetTrigPrice: number, targetQty: number, stopPrice?: number, targetPrice?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaceOCOOrder200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placeOCOOrder(symId, side, stopLossType, stopLossProduct, stopTrigPrice, stopQty, targetType, targetProduct, targetTrigPrice, targetQty, stopPrice, targetPrice, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AdvanceOrdersApi.placeOCOOrder']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * AdvanceOrdersApi - factory interface
 * @export
 */
export const AdvanceOrdersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdvanceOrdersApiFp(configuration)
    return {
        /**
         * to cancel the GTT order
         * @summary Cancel GTT Order
         * @param {string} orderNo Order Number is unique number which will be utilized while modifying and cancelling order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelGTTOrder(orderNo: string, options?: any): AxiosPromise<CancelGTTOrder200Response> {
            return localVarFp.cancelGTTOrder(orderNo, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel A one-cancels-the-other order
         * @summary Cancel OCO Order
         * @param {string} orderNo Order Number is unique number which will be utilized while modifying and cancelling order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOCOOrder(orderNo: string, options?: any): AxiosPromise<CancelOCOOrder200Response> {
            return localVarFp.cancelOCOOrder(orderNo, options).then((request) => request(axios, basePath));
        },
        /**
         * to exit bracket or cover order.
         * @summary Exit Order
         * @param {string} orderId Main leg order id of bracker or cover order should be passed here. It will be received from the field \\\&#39;mainLegOrderId\\\&#39; in orders response
         * @param {ExitOrderProductEnum} product Pass the respective product type bracket or cover here to exit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exitOrder(orderId: string, product: ExitOrderProductEnum, options?: any): AxiosPromise<ExitOrder200Response> {
            return localVarFp.exitOrder(orderId, product, options).then((request) => request(axios, basePath));
        },
        /**
         * to modify the bracket order
         * @summary Modify Bracket Order
         * @param {string} symId Unique identifier of the symbol
         * @param {string} orderId Order id of an order which needs modification. This id will be received in orders service
         * @param {number} qty Total order quantity after the modification. ( Filled Qty (if nonzero) + (Modified Qty or Pending Qty)). Example: If the order quantity is 100, out of that 60 is already filled, and if we are modifying the pending qty from 40 to 70 then qty &#x3D;&gt; (60 + 70) &#x3D; 130 should be sent. 
         * @param {ModifyBracketOrderTypeEnum} type Price type of an order
         * @param {number} stopTrigPrice Stop loss leg trigger price. This is the difference of main leg price and the stop loss leg trigger price. If your main leg order price is \\\&#39;2400\\\&#39; and if you want to set the stop loss trigger at \\\&#39;2300\\\&#39; then pass the difference \\\&#39;100\\\&#39; in this field. 
         * @param {number} targetPrice Target leg price. This is the difference of main leg price and the target leg price. If your main leg order price is \\\&#39;2400\\\&#39; and if you want to set the target or profit order price for 2500 then pass the difference \\\&#39;100\\\&#39; in this field
         * @param {number} [limitPrice] Main leg order price. Required only for \\\&#39;limit\\\&#39; and \\\&#39;stoplimit\\\&#39; orders
         * @param {number} [trigPrice] This is applicable only for the main leg order and required only if the order type is \\\&#39;stoplimit\\\&#39;
         * @param {number} [mktProt] This is applicable only for the main leg order and required only if the order type is \\\&#39;market\\\&#39;
         * @param {number} [trailingStopPrice] Trailing stop loss price.
         * @param {ModifyBracketOrderSideEnum} [side] Order side \\\&#39;buy\\\&#39; or \\\&#39;sell\\\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyBracketOrder(symId: string, orderId: string, qty: number, type: ModifyBracketOrderTypeEnum, stopTrigPrice: number, targetPrice: number, limitPrice?: number, trigPrice?: number, mktProt?: number, trailingStopPrice?: number, side?: ModifyBracketOrderSideEnum, options?: any): AxiosPromise<ModifyOrder200Response> {
            return localVarFp.modifyBracketOrder(symId, orderId, qty, type, stopTrigPrice, targetPrice, limitPrice, trigPrice, mktProt, trailingStopPrice, side, options).then((request) => request(axios, basePath));
        },
        /**
         * to modify the cover order
         * @summary Modify Cover Order
         * @param {string} symId Unique identifier of the symbol
         * @param {string} orderId Order id of an order which needs modification. This id will be received in orders service
         * @param {number} qty Total order quantity after the modification. ( Filled Qty (if nonzero) + (Modified Qty or Pending Qty)). Example: If the order quantity is 100, out of that 60 is already filled, and if we are modifying the pending qty from 40 to 70 then qty &#x3D;&gt; (60 + 70) &#x3D; 130 should be sent. 
         * @param {ModifyCoverOrderTypeEnum} type Price type of an order
         * @param {number} stopTrigPrice Stop loss leg trigger price. This is the difference of main leg price and the stop loss leg trigger price. If your main leg order price is \\\&#39;2400\\\&#39; and if you want to set the stop loss trigger at \\\&#39;2300\\\&#39; then pass the difference \\\&#39;100\\\&#39; in this field. 
         * @param {number} [limitPrice] Main leg order price. Required only for \\\&#39;limit\\\&#39; and \\\&#39;stoplimit\\\&#39; orders
         * @param {number} [trigPrice] This is applicable only for the main leg order and required only if the order type is \\\&#39;stoplimit\\\&#39;
         * @param {number} [mktProt] This is applicable only for the main leg order and required only if the order type is \\\&#39;market\\\&#39;
         * @param {ModifyCoverOrderSideEnum} [side] Order side \\\&#39;buy\\\&#39; or \\\&#39;sell\\\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyCoverOrder(symId: string, orderId: string, qty: number, type: ModifyCoverOrderTypeEnum, stopTrigPrice: number, limitPrice?: number, trigPrice?: number, mktProt?: number, side?: ModifyCoverOrderSideEnum, options?: any): AxiosPromise<ModifyOrder200Response> {
            return localVarFp.modifyCoverOrder(symId, orderId, qty, type, stopTrigPrice, limitPrice, trigPrice, mktProt, side, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify good till triggered order
         * @summary Modify GTT Order
         * @param {string} orderId Order Number is unique number which will be utilized while modifying and cancelling order
         * @param {string} symId Unique identifier of the symbol
         * @param {ModifyGTTOrderSideEnum} side Order id of an order. This will be received in orders response
         * @param {ModifyGTTOrderTypeEnum} type Price type of an order
         * @param {ModifyGTTOrderProductEnum} product Product type of an order. \\\&#39;delivery\\\&#39; is applicable for equities. \\\&#39;normal\\\&#39; is applicable for derivatives. \\\&#39;intraday\\\&#39; is applicable for both equity and derivatives
         * @param {number} trigPricePer Price difference from the LTP in percentage, calculated using the formula: (trigPrice - LTP) / LTP × 100. This value can be positive or negative, depending on whether the trigPrice is above or below the LTP.
         * @param {number} trigPrice Trigger price with respect to LTP
         * @param {number} qty No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.
         * @param {number} [limitPrice] This is required only for limit and stop limit orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyGTTOrder(orderId: string, symId: string, side: ModifyGTTOrderSideEnum, type: ModifyGTTOrderTypeEnum, product: ModifyGTTOrderProductEnum, trigPricePer: number, trigPrice: number, qty: number, limitPrice?: number, options?: any): AxiosPromise<ModifyGTTOrder200Response> {
            return localVarFp.modifyGTTOrder(orderId, symId, side, type, product, trigPricePer, trigPrice, qty, limitPrice, options).then((request) => request(axios, basePath));
        },
        /**
         * Modify one-cancels-the-other order
         * @summary Modify OCO Order
         * @param {string} orderId Order Number is unique number which will be utilized while modifying and cancelling order
         * @param {string} symId Unique identifier of the symbol
         * @param {ModifyOCOOrderSideEnum} side Order id of an order. This will be received in orders response
         * @param {ModifyOCOOrderStopLossTypeEnum} stopLossType Price type of an order
         * @param {ModifyOCOOrderStopLossProductEnum} stopLossProduct Product type of an order. \\\&#39;delivery\\\&#39; is applicable for equities. \\\&#39;normal\\\&#39; is applicable for derivatives. \\\&#39;intraday\\\&#39; is applicable for both equity and derivatives
         * @param {number} stopTrigPrice Stoploss trigger price
         * @param {number} stopQty No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.
         * @param {ModifyOCOOrderTargetTypeEnum} targetType Price type of an order
         * @param {ModifyOCOOrderTargetProductEnum} targetProduct Product type of an order. \\\&#39;delivery\\\&#39; is applicable for equities. \\\&#39;normal\\\&#39; is applicable for derivatives. \\\&#39;intraday\\\&#39; is applicable for both equity and derivatives
         * @param {number} targetTrigPrice Target trigger price
         * @param {number} targetQty No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.
         * @param {number} [stopPrice] This is required only for limit and stop limit orders
         * @param {number} [targetPrice] This is required only for limit and stop limit orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyOCOOrder(orderId: string, symId: string, side: ModifyOCOOrderSideEnum, stopLossType: ModifyOCOOrderStopLossTypeEnum, stopLossProduct: ModifyOCOOrderStopLossProductEnum, stopTrigPrice: number, stopQty: number, targetType: ModifyOCOOrderTargetTypeEnum, targetProduct: ModifyOCOOrderTargetProductEnum, targetTrigPrice: number, targetQty: number, stopPrice?: number, targetPrice?: number, options?: any): AxiosPromise<ModifyOCOOrder200Response> {
            return localVarFp.modifyOCOOrder(orderId, symId, side, stopLossType, stopLossProduct, stopTrigPrice, stopQty, targetType, targetProduct, targetTrigPrice, targetQty, stopPrice, targetPrice, options).then((request) => request(axios, basePath));
        },
        /**
         * to get the list of pending gtt, oco orders orders
         * @summary GTT OrderBook
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pendingGTTOrders(options?: any): AxiosPromise<PendingGTTOrders200Response> {
            return localVarFp.pendingGTTOrders(options).then((request) => request(axios, basePath));
        },
        /**
         * to place the bracket order
         * @summary Place Bracket Order
         * @param {string} symId Unique identifier of the symbol
         * @param {number} qty No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.
         * @param {PlaceBracketOrderSideEnum} side Order side \\\&#39;buy\\\&#39; or \\\&#39;sell\\\&#39;
         * @param {PlaceBracketOrderTypeEnum} type Price type of an order
         * @param {number} stopTrigPrice Stop loss leg trigger price. This is the difference of main leg price and the stop loss leg trigger price. If your main leg order price is \\\&#39;2400\\\&#39; and if you want to set the stop loss trigger at \\\&#39;2300\\\&#39; then pass the difference \\\&#39;100\\\&#39; in this field. 
         * @param {number} targetPrice Target leg price. This is the difference of main leg price and the target leg price. If your main leg order price is \\\&#39;2400\\\&#39; and if you want to set the target or profit order price for 2500 then pass the difference \\\&#39;100\\\&#39; in this field
         * @param {number} [limitPrice] Main leg order price. Required only for \\\&#39;limit\\\&#39; and \\\&#39;stoplimit\\\&#39; orders
         * @param {number} [trigPrice] This is applicable only for the main leg order and required only if the order type is \\\&#39;stoplimit\\\&#39;
         * @param {number} [mktProt] This is applicable only for the main leg order and required only if the order type is \\\&#39;market\\\&#39;
         * @param {number} [trailingStopPrice] Trailing stop loss price.
         * @param {string} [remarks] Any tag or message to track in orderbook.Allowed length upto 10 Characters. Please note remarks more than 10 characters will be stripped out.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeBracketOrder(symId: string, qty: number, side: PlaceBracketOrderSideEnum, type: PlaceBracketOrderTypeEnum, stopTrigPrice: number, targetPrice: number, limitPrice?: number, trigPrice?: number, mktProt?: number, trailingStopPrice?: number, remarks?: string, options?: any): AxiosPromise<PlaceBracketOrder200Response> {
            return localVarFp.placeBracketOrder(symId, qty, side, type, stopTrigPrice, targetPrice, limitPrice, trigPrice, mktProt, trailingStopPrice, remarks, options).then((request) => request(axios, basePath));
        },
        /**
         * to place the cover order
         * @summary Place Cover Order
         * @param {string} symId Unique identifier of the symbol
         * @param {number} qty No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.
         * @param {PlaceCoverOrderSideEnum} side Order side \\\&#39;buy\\\&#39; or \\\&#39;sell\\\&#39;
         * @param {PlaceCoverOrderTypeEnum} type Price type of an order
         * @param {number} stopTrigPrice Stop loss leg trigger price. This is the difference of main leg price and the stop loss leg trigger price. If your main leg order price is \\\&#39;2400\\\&#39; and if you want to set the stop loss trigger at \\\&#39;2300\\\&#39; then pass the difference \\\&#39;100\\\&#39; in this field. 
         * @param {number} [limitPrice] Main leg order price. Required only for \\\&#39;limit\\\&#39; and \\\&#39;stoplimit\\\&#39; orders
         * @param {number} [trigPrice] This is applicable only for the main leg order and required only if the order type is \\\&#39;stoplimit\\\&#39;
         * @param {number} [mktProt] This is applicable only for the main leg order and required only if the order type is \\\&#39;market\\\&#39;
         * @param {string} [remarks] Any tag or message to track in orderbook.Allowed length upto 10 Characters. Please note remarks more than 10 characters will be stripped out.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeCoverOrder(symId: string, qty: number, side: PlaceCoverOrderSideEnum, type: PlaceCoverOrderTypeEnum, stopTrigPrice: number, limitPrice?: number, trigPrice?: number, mktProt?: number, remarks?: string, options?: any): AxiosPromise<PlaceBracketOrder200Response> {
            return localVarFp.placeCoverOrder(symId, qty, side, type, stopTrigPrice, limitPrice, trigPrice, mktProt, remarks, options).then((request) => request(axios, basePath));
        },
        /**
         * Place good till triggered order
         * @summary Place GTT Order
         * @param {string} symId Unique identifier of the symbol
         * @param {PlaceGTTOrderTypeEnum} type Price type of an order
         * @param {PlaceGTTOrderSideEnum} side Order id of an order. This will be received in orders response
         * @param {PlaceGTTOrderProductEnum} product Product type of an order. \\\&#39;delivery\\\&#39; is applicable for equities. \\\&#39;normal\\\&#39; is applicable for derivatives. \\\&#39;intraday\\\&#39; is applicable for both equity and derivatives
         * @param {number} trigPricePer Price difference from the LTP in percentage, calculated using the formula: (trigPrice - LTP) / LTP × 100. This value can be positive or negative, depending on whether the trigPrice is above or below the LTP.
         * @param {number} trigPrice Trigger price with respect to LTP
         * @param {number} qty No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.
         * @param {number} [limitPrice] This is required only for limit and stop limit orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeGTTOrder(symId: string, type: PlaceGTTOrderTypeEnum, side: PlaceGTTOrderSideEnum, product: PlaceGTTOrderProductEnum, trigPricePer: number, trigPrice: number, qty: number, limitPrice?: number, options?: any): AxiosPromise<PlaceGTTOrder200Response> {
            return localVarFp.placeGTTOrder(symId, type, side, product, trigPricePer, trigPrice, qty, limitPrice, options).then((request) => request(axios, basePath));
        },
        /**
         * Place A one-cancels-the-other order
         * @summary Place OCO Order
         * @param {string} symId Unique identifier of the symbol
         * @param {PlaceOCOOrderSideEnum} side Order id of an order. This will be received in orders response
         * @param {PlaceOCOOrderStopLossTypeEnum} stopLossType Price type of an order
         * @param {PlaceOCOOrderStopLossProductEnum} stopLossProduct Product type of an order. \\\&#39;delivery\\\&#39; is applicable for equities. \\\&#39;normal\\\&#39; is applicable for derivatives. \\\&#39;intraday\\\&#39; is applicable for both equity and derivatives
         * @param {number} stopTrigPrice Trigger price with respect to LTP
         * @param {number} stopQty No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.
         * @param {PlaceOCOOrderTargetTypeEnum} targetType Price type of an order
         * @param {PlaceOCOOrderTargetProductEnum} targetProduct Product type of an order. \\\&#39;delivery\\\&#39; is applicable for equities. \\\&#39;normal\\\&#39; is applicable for derivatives. \\\&#39;intraday\\\&#39; is applicable for both equity and derivatives
         * @param {number} targetTrigPrice Trigger price with respect to LTP
         * @param {number} targetQty No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.
         * @param {number} [stopPrice] This is required only for limit and stop limit orders
         * @param {number} [targetPrice] This is required only for limit and stop limit orders
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeOCOOrder(symId: string, side: PlaceOCOOrderSideEnum, stopLossType: PlaceOCOOrderStopLossTypeEnum, stopLossProduct: PlaceOCOOrderStopLossProductEnum, stopTrigPrice: number, stopQty: number, targetType: PlaceOCOOrderTargetTypeEnum, targetProduct: PlaceOCOOrderTargetProductEnum, targetTrigPrice: number, targetQty: number, stopPrice?: number, targetPrice?: number, options?: any): AxiosPromise<PlaceOCOOrder200Response> {
            return localVarFp.placeOCOOrder(symId, side, stopLossType, stopLossProduct, stopTrigPrice, stopQty, targetType, targetProduct, targetTrigPrice, targetQty, stopPrice, targetPrice, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdvanceOrdersApi - object-oriented interface
 * @export
 * @class AdvanceOrdersApi
 * @extends {BaseAPI}
 */
export class AdvanceOrdersApi extends BaseAPI {
    /**
     * to cancel the GTT order
     * @summary Cancel GTT Order
     * @param {string} orderNo Order Number is unique number which will be utilized while modifying and cancelling order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdvanceOrdersApi
     */
    public cancelGTTOrder(orderNo: string, options?: RawAxiosRequestConfig) {
        return AdvanceOrdersApiFp(this.configuration).cancelGTTOrder(orderNo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel A one-cancels-the-other order
     * @summary Cancel OCO Order
     * @param {string} orderNo Order Number is unique number which will be utilized while modifying and cancelling order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdvanceOrdersApi
     */
    public cancelOCOOrder(orderNo: string, options?: RawAxiosRequestConfig) {
        return AdvanceOrdersApiFp(this.configuration).cancelOCOOrder(orderNo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * to exit bracket or cover order.
     * @summary Exit Order
     * @param {string} orderId Main leg order id of bracker or cover order should be passed here. It will be received from the field \\\&#39;mainLegOrderId\\\&#39; in orders response
     * @param {ExitOrderProductEnum} product Pass the respective product type bracket or cover here to exit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdvanceOrdersApi
     */
    public exitOrder(orderId: string, product: ExitOrderProductEnum, options?: RawAxiosRequestConfig) {
        return AdvanceOrdersApiFp(this.configuration).exitOrder(orderId, product, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * to modify the bracket order
     * @summary Modify Bracket Order
     * @param {string} symId Unique identifier of the symbol
     * @param {string} orderId Order id of an order which needs modification. This id will be received in orders service
     * @param {number} qty Total order quantity after the modification. ( Filled Qty (if nonzero) + (Modified Qty or Pending Qty)). Example: If the order quantity is 100, out of that 60 is already filled, and if we are modifying the pending qty from 40 to 70 then qty &#x3D;&gt; (60 + 70) &#x3D; 130 should be sent. 
     * @param {ModifyBracketOrderTypeEnum} type Price type of an order
     * @param {number} stopTrigPrice Stop loss leg trigger price. This is the difference of main leg price and the stop loss leg trigger price. If your main leg order price is \\\&#39;2400\\\&#39; and if you want to set the stop loss trigger at \\\&#39;2300\\\&#39; then pass the difference \\\&#39;100\\\&#39; in this field. 
     * @param {number} targetPrice Target leg price. This is the difference of main leg price and the target leg price. If your main leg order price is \\\&#39;2400\\\&#39; and if you want to set the target or profit order price for 2500 then pass the difference \\\&#39;100\\\&#39; in this field
     * @param {number} [limitPrice] Main leg order price. Required only for \\\&#39;limit\\\&#39; and \\\&#39;stoplimit\\\&#39; orders
     * @param {number} [trigPrice] This is applicable only for the main leg order and required only if the order type is \\\&#39;stoplimit\\\&#39;
     * @param {number} [mktProt] This is applicable only for the main leg order and required only if the order type is \\\&#39;market\\\&#39;
     * @param {number} [trailingStopPrice] Trailing stop loss price.
     * @param {ModifyBracketOrderSideEnum} [side] Order side \\\&#39;buy\\\&#39; or \\\&#39;sell\\\&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdvanceOrdersApi
     */
    public modifyBracketOrder(symId: string, orderId: string, qty: number, type: ModifyBracketOrderTypeEnum, stopTrigPrice: number, targetPrice: number, limitPrice?: number, trigPrice?: number, mktProt?: number, trailingStopPrice?: number, side?: ModifyBracketOrderSideEnum, options?: RawAxiosRequestConfig) {
        return AdvanceOrdersApiFp(this.configuration).modifyBracketOrder(symId, orderId, qty, type, stopTrigPrice, targetPrice, limitPrice, trigPrice, mktProt, trailingStopPrice, side, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * to modify the cover order
     * @summary Modify Cover Order
     * @param {string} symId Unique identifier of the symbol
     * @param {string} orderId Order id of an order which needs modification. This id will be received in orders service
     * @param {number} qty Total order quantity after the modification. ( Filled Qty (if nonzero) + (Modified Qty or Pending Qty)). Example: If the order quantity is 100, out of that 60 is already filled, and if we are modifying the pending qty from 40 to 70 then qty &#x3D;&gt; (60 + 70) &#x3D; 130 should be sent. 
     * @param {ModifyCoverOrderTypeEnum} type Price type of an order
     * @param {number} stopTrigPrice Stop loss leg trigger price. This is the difference of main leg price and the stop loss leg trigger price. If your main leg order price is \\\&#39;2400\\\&#39; and if you want to set the stop loss trigger at \\\&#39;2300\\\&#39; then pass the difference \\\&#39;100\\\&#39; in this field. 
     * @param {number} [limitPrice] Main leg order price. Required only for \\\&#39;limit\\\&#39; and \\\&#39;stoplimit\\\&#39; orders
     * @param {number} [trigPrice] This is applicable only for the main leg order and required only if the order type is \\\&#39;stoplimit\\\&#39;
     * @param {number} [mktProt] This is applicable only for the main leg order and required only if the order type is \\\&#39;market\\\&#39;
     * @param {ModifyCoverOrderSideEnum} [side] Order side \\\&#39;buy\\\&#39; or \\\&#39;sell\\\&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdvanceOrdersApi
     */
    public modifyCoverOrder(symId: string, orderId: string, qty: number, type: ModifyCoverOrderTypeEnum, stopTrigPrice: number, limitPrice?: number, trigPrice?: number, mktProt?: number, side?: ModifyCoverOrderSideEnum, options?: RawAxiosRequestConfig) {
        return AdvanceOrdersApiFp(this.configuration).modifyCoverOrder(symId, orderId, qty, type, stopTrigPrice, limitPrice, trigPrice, mktProt, side, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modify good till triggered order
     * @summary Modify GTT Order
     * @param {string} orderId Order Number is unique number which will be utilized while modifying and cancelling order
     * @param {string} symId Unique identifier of the symbol
     * @param {ModifyGTTOrderSideEnum} side Order id of an order. This will be received in orders response
     * @param {ModifyGTTOrderTypeEnum} type Price type of an order
     * @param {ModifyGTTOrderProductEnum} product Product type of an order. \\\&#39;delivery\\\&#39; is applicable for equities. \\\&#39;normal\\\&#39; is applicable for derivatives. \\\&#39;intraday\\\&#39; is applicable for both equity and derivatives
     * @param {number} trigPricePer Price difference from the LTP in percentage, calculated using the formula: (trigPrice - LTP) / LTP × 100. This value can be positive or negative, depending on whether the trigPrice is above or below the LTP.
     * @param {number} trigPrice Trigger price with respect to LTP
     * @param {number} qty No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.
     * @param {number} [limitPrice] This is required only for limit and stop limit orders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdvanceOrdersApi
     */
    public modifyGTTOrder(orderId: string, symId: string, side: ModifyGTTOrderSideEnum, type: ModifyGTTOrderTypeEnum, product: ModifyGTTOrderProductEnum, trigPricePer: number, trigPrice: number, qty: number, limitPrice?: number, options?: RawAxiosRequestConfig) {
        return AdvanceOrdersApiFp(this.configuration).modifyGTTOrder(orderId, symId, side, type, product, trigPricePer, trigPrice, qty, limitPrice, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Modify one-cancels-the-other order
     * @summary Modify OCO Order
     * @param {string} orderId Order Number is unique number which will be utilized while modifying and cancelling order
     * @param {string} symId Unique identifier of the symbol
     * @param {ModifyOCOOrderSideEnum} side Order id of an order. This will be received in orders response
     * @param {ModifyOCOOrderStopLossTypeEnum} stopLossType Price type of an order
     * @param {ModifyOCOOrderStopLossProductEnum} stopLossProduct Product type of an order. \\\&#39;delivery\\\&#39; is applicable for equities. \\\&#39;normal\\\&#39; is applicable for derivatives. \\\&#39;intraday\\\&#39; is applicable for both equity and derivatives
     * @param {number} stopTrigPrice Stoploss trigger price
     * @param {number} stopQty No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.
     * @param {ModifyOCOOrderTargetTypeEnum} targetType Price type of an order
     * @param {ModifyOCOOrderTargetProductEnum} targetProduct Product type of an order. \\\&#39;delivery\\\&#39; is applicable for equities. \\\&#39;normal\\\&#39; is applicable for derivatives. \\\&#39;intraday\\\&#39; is applicable for both equity and derivatives
     * @param {number} targetTrigPrice Target trigger price
     * @param {number} targetQty No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.
     * @param {number} [stopPrice] This is required only for limit and stop limit orders
     * @param {number} [targetPrice] This is required only for limit and stop limit orders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdvanceOrdersApi
     */
    public modifyOCOOrder(orderId: string, symId: string, side: ModifyOCOOrderSideEnum, stopLossType: ModifyOCOOrderStopLossTypeEnum, stopLossProduct: ModifyOCOOrderStopLossProductEnum, stopTrigPrice: number, stopQty: number, targetType: ModifyOCOOrderTargetTypeEnum, targetProduct: ModifyOCOOrderTargetProductEnum, targetTrigPrice: number, targetQty: number, stopPrice?: number, targetPrice?: number, options?: RawAxiosRequestConfig) {
        return AdvanceOrdersApiFp(this.configuration).modifyOCOOrder(orderId, symId, side, stopLossType, stopLossProduct, stopTrigPrice, stopQty, targetType, targetProduct, targetTrigPrice, targetQty, stopPrice, targetPrice, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * to get the list of pending gtt, oco orders orders
     * @summary GTT OrderBook
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdvanceOrdersApi
     */
    public pendingGTTOrders(options?: RawAxiosRequestConfig) {
        return AdvanceOrdersApiFp(this.configuration).pendingGTTOrders(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * to place the bracket order
     * @summary Place Bracket Order
     * @param {string} symId Unique identifier of the symbol
     * @param {number} qty No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.
     * @param {PlaceBracketOrderSideEnum} side Order side \\\&#39;buy\\\&#39; or \\\&#39;sell\\\&#39;
     * @param {PlaceBracketOrderTypeEnum} type Price type of an order
     * @param {number} stopTrigPrice Stop loss leg trigger price. This is the difference of main leg price and the stop loss leg trigger price. If your main leg order price is \\\&#39;2400\\\&#39; and if you want to set the stop loss trigger at \\\&#39;2300\\\&#39; then pass the difference \\\&#39;100\\\&#39; in this field. 
     * @param {number} targetPrice Target leg price. This is the difference of main leg price and the target leg price. If your main leg order price is \\\&#39;2400\\\&#39; and if you want to set the target or profit order price for 2500 then pass the difference \\\&#39;100\\\&#39; in this field
     * @param {number} [limitPrice] Main leg order price. Required only for \\\&#39;limit\\\&#39; and \\\&#39;stoplimit\\\&#39; orders
     * @param {number} [trigPrice] This is applicable only for the main leg order and required only if the order type is \\\&#39;stoplimit\\\&#39;
     * @param {number} [mktProt] This is applicable only for the main leg order and required only if the order type is \\\&#39;market\\\&#39;
     * @param {number} [trailingStopPrice] Trailing stop loss price.
     * @param {string} [remarks] Any tag or message to track in orderbook.Allowed length upto 10 Characters. Please note remarks more than 10 characters will be stripped out.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdvanceOrdersApi
     */
    public placeBracketOrder(symId: string, qty: number, side: PlaceBracketOrderSideEnum, type: PlaceBracketOrderTypeEnum, stopTrigPrice: number, targetPrice: number, limitPrice?: number, trigPrice?: number, mktProt?: number, trailingStopPrice?: number, remarks?: string, options?: RawAxiosRequestConfig) {
        return AdvanceOrdersApiFp(this.configuration).placeBracketOrder(symId, qty, side, type, stopTrigPrice, targetPrice, limitPrice, trigPrice, mktProt, trailingStopPrice, remarks, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * to place the cover order
     * @summary Place Cover Order
     * @param {string} symId Unique identifier of the symbol
     * @param {number} qty No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.
     * @param {PlaceCoverOrderSideEnum} side Order side \\\&#39;buy\\\&#39; or \\\&#39;sell\\\&#39;
     * @param {PlaceCoverOrderTypeEnum} type Price type of an order
     * @param {number} stopTrigPrice Stop loss leg trigger price. This is the difference of main leg price and the stop loss leg trigger price. If your main leg order price is \\\&#39;2400\\\&#39; and if you want to set the stop loss trigger at \\\&#39;2300\\\&#39; then pass the difference \\\&#39;100\\\&#39; in this field. 
     * @param {number} [limitPrice] Main leg order price. Required only for \\\&#39;limit\\\&#39; and \\\&#39;stoplimit\\\&#39; orders
     * @param {number} [trigPrice] This is applicable only for the main leg order and required only if the order type is \\\&#39;stoplimit\\\&#39;
     * @param {number} [mktProt] This is applicable only for the main leg order and required only if the order type is \\\&#39;market\\\&#39;
     * @param {string} [remarks] Any tag or message to track in orderbook.Allowed length upto 10 Characters. Please note remarks more than 10 characters will be stripped out.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdvanceOrdersApi
     */
    public placeCoverOrder(symId: string, qty: number, side: PlaceCoverOrderSideEnum, type: PlaceCoverOrderTypeEnum, stopTrigPrice: number, limitPrice?: number, trigPrice?: number, mktProt?: number, remarks?: string, options?: RawAxiosRequestConfig) {
        return AdvanceOrdersApiFp(this.configuration).placeCoverOrder(symId, qty, side, type, stopTrigPrice, limitPrice, trigPrice, mktProt, remarks, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Place good till triggered order
     * @summary Place GTT Order
     * @param {string} symId Unique identifier of the symbol
     * @param {PlaceGTTOrderTypeEnum} type Price type of an order
     * @param {PlaceGTTOrderSideEnum} side Order id of an order. This will be received in orders response
     * @param {PlaceGTTOrderProductEnum} product Product type of an order. \\\&#39;delivery\\\&#39; is applicable for equities. \\\&#39;normal\\\&#39; is applicable for derivatives. \\\&#39;intraday\\\&#39; is applicable for both equity and derivatives
     * @param {number} trigPricePer Price difference from the LTP in percentage, calculated using the formula: (trigPrice - LTP) / LTP × 100. This value can be positive or negative, depending on whether the trigPrice is above or below the LTP.
     * @param {number} trigPrice Trigger price with respect to LTP
     * @param {number} qty No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.
     * @param {number} [limitPrice] This is required only for limit and stop limit orders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdvanceOrdersApi
     */
    public placeGTTOrder(symId: string, type: PlaceGTTOrderTypeEnum, side: PlaceGTTOrderSideEnum, product: PlaceGTTOrderProductEnum, trigPricePer: number, trigPrice: number, qty: number, limitPrice?: number, options?: RawAxiosRequestConfig) {
        return AdvanceOrdersApiFp(this.configuration).placeGTTOrder(symId, type, side, product, trigPricePer, trigPrice, qty, limitPrice, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Place A one-cancels-the-other order
     * @summary Place OCO Order
     * @param {string} symId Unique identifier of the symbol
     * @param {PlaceOCOOrderSideEnum} side Order id of an order. This will be received in orders response
     * @param {PlaceOCOOrderStopLossTypeEnum} stopLossType Price type of an order
     * @param {PlaceOCOOrderStopLossProductEnum} stopLossProduct Product type of an order. \\\&#39;delivery\\\&#39; is applicable for equities. \\\&#39;normal\\\&#39; is applicable for derivatives. \\\&#39;intraday\\\&#39; is applicable for both equity and derivatives
     * @param {number} stopTrigPrice Trigger price with respect to LTP
     * @param {number} stopQty No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.
     * @param {PlaceOCOOrderTargetTypeEnum} targetType Price type of an order
     * @param {PlaceOCOOrderTargetProductEnum} targetProduct Product type of an order. \\\&#39;delivery\\\&#39; is applicable for equities. \\\&#39;normal\\\&#39; is applicable for derivatives. \\\&#39;intraday\\\&#39; is applicable for both equity and derivatives
     * @param {number} targetTrigPrice Trigger price with respect to LTP
     * @param {number} targetQty No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.
     * @param {number} [stopPrice] This is required only for limit and stop limit orders
     * @param {number} [targetPrice] This is required only for limit and stop limit orders
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdvanceOrdersApi
     */
    public placeOCOOrder(symId: string, side: PlaceOCOOrderSideEnum, stopLossType: PlaceOCOOrderStopLossTypeEnum, stopLossProduct: PlaceOCOOrderStopLossProductEnum, stopTrigPrice: number, stopQty: number, targetType: PlaceOCOOrderTargetTypeEnum, targetProduct: PlaceOCOOrderTargetProductEnum, targetTrigPrice: number, targetQty: number, stopPrice?: number, targetPrice?: number, options?: RawAxiosRequestConfig) {
        return AdvanceOrdersApiFp(this.configuration).placeOCOOrder(symId, side, stopLossType, stopLossProduct, stopTrigPrice, stopQty, targetType, targetProduct, targetTrigPrice, targetQty, stopPrice, targetPrice, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ExitOrderProductEnum = {
    Bracket: 'bracket',
    Cover: 'cover'
} as const;
export type ExitOrderProductEnum = typeof ExitOrderProductEnum[keyof typeof ExitOrderProductEnum];
/**
 * @export
 */
export const ModifyBracketOrderTypeEnum = {
    Limit: 'limit',
    Market: 'market',
    Stoplimit: 'stoplimit'
} as const;
export type ModifyBracketOrderTypeEnum = typeof ModifyBracketOrderTypeEnum[keyof typeof ModifyBracketOrderTypeEnum];
/**
 * @export
 */
export const ModifyBracketOrderSideEnum = {
    Buy: 'buy',
    Sell: 'sell'
} as const;
export type ModifyBracketOrderSideEnum = typeof ModifyBracketOrderSideEnum[keyof typeof ModifyBracketOrderSideEnum];
/**
 * @export
 */
export const ModifyCoverOrderTypeEnum = {
    Limit: 'limit',
    Market: 'market',
    Stoplimit: 'stoplimit'
} as const;
export type ModifyCoverOrderTypeEnum = typeof ModifyCoverOrderTypeEnum[keyof typeof ModifyCoverOrderTypeEnum];
/**
 * @export
 */
export const ModifyCoverOrderSideEnum = {
    Buy: 'buy',
    Sell: 'sell'
} as const;
export type ModifyCoverOrderSideEnum = typeof ModifyCoverOrderSideEnum[keyof typeof ModifyCoverOrderSideEnum];
/**
 * @export
 */
export const ModifyGTTOrderSideEnum = {
    Buy: 'buy',
    Sell: 'sell'
} as const;
export type ModifyGTTOrderSideEnum = typeof ModifyGTTOrderSideEnum[keyof typeof ModifyGTTOrderSideEnum];
/**
 * @export
 */
export const ModifyGTTOrderTypeEnum = {
    Limit: 'limit'
} as const;
export type ModifyGTTOrderTypeEnum = typeof ModifyGTTOrderTypeEnum[keyof typeof ModifyGTTOrderTypeEnum];
/**
 * @export
 */
export const ModifyGTTOrderProductEnum = {
    Delivery: 'delivery',
    Normal: 'normal'
} as const;
export type ModifyGTTOrderProductEnum = typeof ModifyGTTOrderProductEnum[keyof typeof ModifyGTTOrderProductEnum];
/**
 * @export
 */
export const ModifyOCOOrderSideEnum = {
    Buy: 'buy',
    Sell: 'sell'
} as const;
export type ModifyOCOOrderSideEnum = typeof ModifyOCOOrderSideEnum[keyof typeof ModifyOCOOrderSideEnum];
/**
 * @export
 */
export const ModifyOCOOrderStopLossTypeEnum = {
    Limit: 'limit'
} as const;
export type ModifyOCOOrderStopLossTypeEnum = typeof ModifyOCOOrderStopLossTypeEnum[keyof typeof ModifyOCOOrderStopLossTypeEnum];
/**
 * @export
 */
export const ModifyOCOOrderStopLossProductEnum = {
    Delivery: 'delivery',
    Normal: 'normal'
} as const;
export type ModifyOCOOrderStopLossProductEnum = typeof ModifyOCOOrderStopLossProductEnum[keyof typeof ModifyOCOOrderStopLossProductEnum];
/**
 * @export
 */
export const ModifyOCOOrderTargetTypeEnum = {
    Limit: 'limit'
} as const;
export type ModifyOCOOrderTargetTypeEnum = typeof ModifyOCOOrderTargetTypeEnum[keyof typeof ModifyOCOOrderTargetTypeEnum];
/**
 * @export
 */
export const ModifyOCOOrderTargetProductEnum = {
    Delivery: 'delivery',
    Normal: 'normal'
} as const;
export type ModifyOCOOrderTargetProductEnum = typeof ModifyOCOOrderTargetProductEnum[keyof typeof ModifyOCOOrderTargetProductEnum];
/**
 * @export
 */
export const PlaceBracketOrderSideEnum = {
    Buy: 'buy',
    Sell: 'sell'
} as const;
export type PlaceBracketOrderSideEnum = typeof PlaceBracketOrderSideEnum[keyof typeof PlaceBracketOrderSideEnum];
/**
 * @export
 */
export const PlaceBracketOrderTypeEnum = {
    Limit: 'limit',
    Market: 'market',
    Stoplimit: 'stoplimit'
} as const;
export type PlaceBracketOrderTypeEnum = typeof PlaceBracketOrderTypeEnum[keyof typeof PlaceBracketOrderTypeEnum];
/**
 * @export
 */
export const PlaceCoverOrderSideEnum = {
    Buy: 'buy',
    Sell: 'sell'
} as const;
export type PlaceCoverOrderSideEnum = typeof PlaceCoverOrderSideEnum[keyof typeof PlaceCoverOrderSideEnum];
/**
 * @export
 */
export const PlaceCoverOrderTypeEnum = {
    Limit: 'limit',
    Market: 'market',
    Stoplimit: 'stoplimit'
} as const;
export type PlaceCoverOrderTypeEnum = typeof PlaceCoverOrderTypeEnum[keyof typeof PlaceCoverOrderTypeEnum];
/**
 * @export
 */
export const PlaceGTTOrderTypeEnum = {
    Limit: 'limit'
} as const;
export type PlaceGTTOrderTypeEnum = typeof PlaceGTTOrderTypeEnum[keyof typeof PlaceGTTOrderTypeEnum];
/**
 * @export
 */
export const PlaceGTTOrderSideEnum = {
    Buy: 'buy',
    Sell: 'sell'
} as const;
export type PlaceGTTOrderSideEnum = typeof PlaceGTTOrderSideEnum[keyof typeof PlaceGTTOrderSideEnum];
/**
 * @export
 */
export const PlaceGTTOrderProductEnum = {
    Delivery: 'delivery',
    Normal: 'normal'
} as const;
export type PlaceGTTOrderProductEnum = typeof PlaceGTTOrderProductEnum[keyof typeof PlaceGTTOrderProductEnum];
/**
 * @export
 */
export const PlaceOCOOrderSideEnum = {
    Buy: 'buy',
    Sell: 'sell'
} as const;
export type PlaceOCOOrderSideEnum = typeof PlaceOCOOrderSideEnum[keyof typeof PlaceOCOOrderSideEnum];
/**
 * @export
 */
export const PlaceOCOOrderStopLossTypeEnum = {
    Limit: 'limit'
} as const;
export type PlaceOCOOrderStopLossTypeEnum = typeof PlaceOCOOrderStopLossTypeEnum[keyof typeof PlaceOCOOrderStopLossTypeEnum];
/**
 * @export
 */
export const PlaceOCOOrderStopLossProductEnum = {
    Delivery: 'delivery',
    Normal: 'normal'
} as const;
export type PlaceOCOOrderStopLossProductEnum = typeof PlaceOCOOrderStopLossProductEnum[keyof typeof PlaceOCOOrderStopLossProductEnum];
/**
 * @export
 */
export const PlaceOCOOrderTargetTypeEnum = {
    Limit: 'limit'
} as const;
export type PlaceOCOOrderTargetTypeEnum = typeof PlaceOCOOrderTargetTypeEnum[keyof typeof PlaceOCOOrderTargetTypeEnum];
/**
 * @export
 */
export const PlaceOCOOrderTargetProductEnum = {
    Delivery: 'delivery',
    Normal: 'normal'
} as const;
export type PlaceOCOOrderTargetProductEnum = typeof PlaceOCOOrderTargetProductEnum[keyof typeof PlaceOCOOrderTargetProductEnum];


/**
 * AuthorizationApi - axios parameter creator
 * @export
 */
export const AuthorizationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Authorize to get oAuth code. </br><span style=\'color:red\'>This API cannot be test from this API document since it is been redirected.</span>
         * @summary Authorize
         * @param {string} clientId This field value should be the API key mentioned in the registered app. If the value is improper authorization will not be allowed.
         * @param {string} redirectUri This field value should be the redirect url mentioned in the registered app. If the value is improper authorization will not be allowed.
         * @param {AuthorizeResponseTypeEnum} responseType As per oAuth specification this value should be __\&quot;code\&quot;__
         * @param {AuthorizeScopeEnum} scope This field value should be __\&quot;general\&quot;__.
         * @param {string} state A literal string that will be return in the final redirection callback.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorize: async (clientId: string, redirectUri: string, responseType: AuthorizeResponseTypeEnum, scope: AuthorizeScopeEnum, state: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('authorize', 'clientId', clientId)
            // verify required parameter 'redirectUri' is not null or undefined
            assertParamExists('authorize', 'redirectUri', redirectUri)
            // verify required parameter 'responseType' is not null or undefined
            assertParamExists('authorize', 'responseType', responseType)
            // verify required parameter 'scope' is not null or undefined
            assertParamExists('authorize', 'scope', scope)
            // verify required parameter 'state' is not null or undefined
            assertParamExists('authorize', 'state', state)
            const localVarPath = `/api-gw/oauth/authorize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (clientId !== undefined) {
                localVarQueryParameter['client_id'] = clientId;
            }

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirect_uri'] = redirectUri;
            }

            if (responseType !== undefined) {
                localVarQueryParameter['response_type'] = responseType;
            }

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This service is used to get access token from the code which is received from final redirection call back.
         * @summary Access token
         * @param {string} code This field value will be same as code received in the final redirection callback.
         * @param {string} clientId This field value should be the API key mentioned in the registered app. If the value is improper access token will not be generated.
         * @param {string} redirectUri This field value should be the redirect url mentioned in the registered app. If the value is improper access token will not be generated.
         * @param {string} clientSecret This field value should be the API secret provided at the app registration. If the value is improper access token will not be generated.
         * @param {GetAccessTokenGrantTypeEnum} grantType As per oAuth specification this value should be __\\\&quot;authorization_code\\\&quot;__
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessToken: async (code: string, clientId: string, redirectUri: string, clientSecret: string, grantType: GetAccessTokenGrantTypeEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('getAccessToken', 'code', code)
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('getAccessToken', 'clientId', clientId)
            // verify required parameter 'redirectUri' is not null or undefined
            assertParamExists('getAccessToken', 'redirectUri', redirectUri)
            // verify required parameter 'clientSecret' is not null or undefined
            assertParamExists('getAccessToken', 'clientSecret', clientSecret)
            // verify required parameter 'grantType' is not null or undefined
            assertParamExists('getAccessToken', 'grantType', grantType)
            const localVarPath = `/api-gw/oauth/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (code !== undefined) { 
                localVarFormParams.set('code', code as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }
    
            if (redirectUri !== undefined) { 
                localVarFormParams.set('redirect_uri', redirectUri as any);
            }
    
            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }
    
            if (grantType !== undefined) { 
                localVarFormParams.set('grant_type', grantType as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authorize to place orders and get oAuth Code to the redirect url at once.</br><span style=\'color:red\'>This API cannot be test from this API document since it is been redirected.</span>
         * @summary Order Connect [Offsite Orders]
         * @param {string} clientId This field value should be the API key mentioned in the registered app. If the value is improper authorization will not be allowed.
         * @param {string} redirectUri This field value should be the redirect url mentioned in the registered app. If the value is improper authorization will not be allowed.
         * @param {OrderAuthorizeResponseTypeEnum} responseType As per oAuth specification this value should be __\&quot;code\&quot;__
         * @param {OrderAuthorizeScopeEnum} scope This field value should be __\&quot;general\&quot;__.
         * @param {string} state A literal string that will be return in the final redirection callback.
         * @param {string} params This field value should be the params required to place orders in json array format and get oAuth Code. &lt;/br&gt;&lt;span style&#x3D;\&#39;color:red\&#39;&gt;Each array value should match any of examples provided. Else your authorization will be failed.&lt;/span&gt;&lt;/br&gt; Example :&#x60;&#x60;&#x60;[{\&quot;exch\&quot;:\&quot;NSE\&quot;,\&quot;symbol\&quot;:\&quot;ACC\&quot;,\&quot;series\&quot;:\&quot;EQ\&quot;,\&quot;inst\&quot;:\&quot;EQT\&quot;,\&quot;qty\&quot;:10,\&quot;side\&quot;:\&quot;buy\&quot;,\&quot;type\&quot;:\&quot;limit\&quot;,\&quot;product\&quot;:\&quot;intraday\&quot;,\&quot;limitPrice\&quot;:2700.55,\&quot;validity\&quot;:\&quot;day\&quot;},{\&quot;exch\&quot;:\&quot;NFO\&quot;,\&quot;symbol\&quot;:\&quot;NIFTY\&quot;,\&quot;expiry\&quot;:\&quot;2022-11-24\&quot;,\&quot;inst\&quot;:\&quot;FUTIDX\&quot;,\&quot;qty\&quot;:2000,\&quot;side\&quot;:\&quot;sell\&quot;,\&quot;type\&quot;:\&quot;market\&quot;,\&quot;product\&quot;:\&quot;intraday\&quot;,\&quot;limitPrice\&quot;:0,\&quot;validity\&quot;:\&quot;ioc\&quot;,\&quot;discQty\&quot;:500},{\&quot;exch\&quot;:\&quot;NFO\&quot;,\&quot;symbol\&quot;:\&quot;BANKNIFTY\&quot;,\&quot;expiry\&quot;:\&quot;2022-11-24\&quot;,\&quot;optType\&quot;:\&quot;PE\&quot;,\&quot;inst\&quot;:\&quot;OPTIDX\&quot;,\&quot;strike\&quot;:\&quot;34000\&quot;,\&quot;qty\&quot;:1500,\&quot;side\&quot;:\&quot;buy\&quot;,\&quot;type\&quot;:\&quot;market\&quot;,\&quot;product\&quot;:\&quot;delivery\&quot;,\&quot;limitPrice\&quot;:0,\&quot;validity\&quot;:\&quot;day\&quot;,\&quot;mktProt\&quot;:5}]&#x60;&#x60;&#x60;&lt;/br&gt; For equity symbol instrument must be \&quot;EQT\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAuthorize: async (clientId: string, redirectUri: string, responseType: OrderAuthorizeResponseTypeEnum, scope: OrderAuthorizeScopeEnum, state: string, params: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'clientId' is not null or undefined
            assertParamExists('orderAuthorize', 'clientId', clientId)
            // verify required parameter 'redirectUri' is not null or undefined
            assertParamExists('orderAuthorize', 'redirectUri', redirectUri)
            // verify required parameter 'responseType' is not null or undefined
            assertParamExists('orderAuthorize', 'responseType', responseType)
            // verify required parameter 'scope' is not null or undefined
            assertParamExists('orderAuthorize', 'scope', scope)
            // verify required parameter 'state' is not null or undefined
            assertParamExists('orderAuthorize', 'state', state)
            // verify required parameter 'params' is not null or undefined
            assertParamExists('orderAuthorize', 'params', params)
            const localVarPath = `/api-gw/oauth/order-connect`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (clientId !== undefined) {
                localVarQueryParameter['client_id'] = clientId;
            }

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirect_uri'] = redirectUri;
            }

            if (responseType !== undefined) {
                localVarQueryParameter['response_type'] = responseType;
            }

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (params !== undefined) {
                localVarQueryParameter['params'] = params;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This service is an updated version with 2Fa login flow.</br>This service is used to get access token for the individual app registration in the developer portal.</br>Using this api direct login is possible from any programming language
         * @summary Individual Token service
         * @param {string} authorization The value should be in the following format :&lt;/br&gt;Bearer clientID&lt;/br&gt;*ClientID refers to API key in developer portal.
         * @param {string} password 
         * @param {string} twoFa **DOB or PAN will not be accepted as 2FA from 30th September 2022 as per exchange regulations. OTP or Time based OTP should be passed for this field. To get the OTP for your client code, login into the web app &lt;a href&#x3D;\\\&#39;https://cubeplus.tradejini.com/\\\&#39; target&#x3D;\\\&#39;_blank\\\&#39; &gt;link&lt;/a&gt; and in the 2FA page, click \\\&#39;Having trouble with AppCode/TOTP\\\&#39; to see \\\&#39;Send SMS / Email OTP\\\&#39; option to generate OTP.**  **For Time based OTP, login into this &lt;a href&#x3D;\\\&#39;https://cubeplus.tradejini.com/\\\&#39; target&#x3D;\\\&#39;_blank\\\&#39; &gt;link&lt;/a&gt; and set up the Authenticator app to generate time based OTP by scanning the QR code provided under the Settings section.**
         * @param {UpdatedIndividualTokenTwoFaTypEnum} twoFaTyp **Enter the type of twoFa based on your twoFa field input.**
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatedIndividualToken: async (authorization: string, password: string, twoFa: string, twoFaTyp: UpdatedIndividualTokenTwoFaTypEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('updatedIndividualToken', 'authorization', authorization)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('updatedIndividualToken', 'password', password)
            // verify required parameter 'twoFa' is not null or undefined
            assertParamExists('updatedIndividualToken', 'twoFa', twoFa)
            // verify required parameter 'twoFaTyp' is not null or undefined
            assertParamExists('updatedIndividualToken', 'twoFaTyp', twoFaTyp)
            const localVarPath = `/api-gw/oauth/individual-token-v2`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }


            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
            if (twoFa !== undefined) { 
                localVarFormParams.set('twoFa', twoFa as any);
            }
    
            if (twoFaTyp !== undefined) { 
                localVarFormParams.set('twoFaTyp', twoFaTyp as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthorizationApi - functional programming interface
 * @export
 */
export const AuthorizationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthorizationApiAxiosParamCreator(configuration)
    return {
        /**
         * Authorize to get oAuth code. </br><span style=\'color:red\'>This API cannot be test from this API document since it is been redirected.</span>
         * @summary Authorize
         * @param {string} clientId This field value should be the API key mentioned in the registered app. If the value is improper authorization will not be allowed.
         * @param {string} redirectUri This field value should be the redirect url mentioned in the registered app. If the value is improper authorization will not be allowed.
         * @param {AuthorizeResponseTypeEnum} responseType As per oAuth specification this value should be __\&quot;code\&quot;__
         * @param {AuthorizeScopeEnum} scope This field value should be __\&quot;general\&quot;__.
         * @param {string} state A literal string that will be return in the final redirection callback.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorize(clientId: string, redirectUri: string, responseType: AuthorizeResponseTypeEnum, scope: AuthorizeScopeEnum, state: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorize(clientId, redirectUri, responseType, scope, state, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthorizationApi.authorize']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This service is used to get access token from the code which is received from final redirection call back.
         * @summary Access token
         * @param {string} code This field value will be same as code received in the final redirection callback.
         * @param {string} clientId This field value should be the API key mentioned in the registered app. If the value is improper access token will not be generated.
         * @param {string} redirectUri This field value should be the redirect url mentioned in the registered app. If the value is improper access token will not be generated.
         * @param {string} clientSecret This field value should be the API secret provided at the app registration. If the value is improper access token will not be generated.
         * @param {GetAccessTokenGrantTypeEnum} grantType As per oAuth specification this value should be __\\\&quot;authorization_code\\\&quot;__
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessToken(code: string, clientId: string, redirectUri: string, clientSecret: string, grantType: GetAccessTokenGrantTypeEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessToken(code, clientId, redirectUri, clientSecret, grantType, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthorizationApi.getAccessToken']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Authorize to place orders and get oAuth Code to the redirect url at once.</br><span style=\'color:red\'>This API cannot be test from this API document since it is been redirected.</span>
         * @summary Order Connect [Offsite Orders]
         * @param {string} clientId This field value should be the API key mentioned in the registered app. If the value is improper authorization will not be allowed.
         * @param {string} redirectUri This field value should be the redirect url mentioned in the registered app. If the value is improper authorization will not be allowed.
         * @param {OrderAuthorizeResponseTypeEnum} responseType As per oAuth specification this value should be __\&quot;code\&quot;__
         * @param {OrderAuthorizeScopeEnum} scope This field value should be __\&quot;general\&quot;__.
         * @param {string} state A literal string that will be return in the final redirection callback.
         * @param {string} params This field value should be the params required to place orders in json array format and get oAuth Code. &lt;/br&gt;&lt;span style&#x3D;\&#39;color:red\&#39;&gt;Each array value should match any of examples provided. Else your authorization will be failed.&lt;/span&gt;&lt;/br&gt; Example :&#x60;&#x60;&#x60;[{\&quot;exch\&quot;:\&quot;NSE\&quot;,\&quot;symbol\&quot;:\&quot;ACC\&quot;,\&quot;series\&quot;:\&quot;EQ\&quot;,\&quot;inst\&quot;:\&quot;EQT\&quot;,\&quot;qty\&quot;:10,\&quot;side\&quot;:\&quot;buy\&quot;,\&quot;type\&quot;:\&quot;limit\&quot;,\&quot;product\&quot;:\&quot;intraday\&quot;,\&quot;limitPrice\&quot;:2700.55,\&quot;validity\&quot;:\&quot;day\&quot;},{\&quot;exch\&quot;:\&quot;NFO\&quot;,\&quot;symbol\&quot;:\&quot;NIFTY\&quot;,\&quot;expiry\&quot;:\&quot;2022-11-24\&quot;,\&quot;inst\&quot;:\&quot;FUTIDX\&quot;,\&quot;qty\&quot;:2000,\&quot;side\&quot;:\&quot;sell\&quot;,\&quot;type\&quot;:\&quot;market\&quot;,\&quot;product\&quot;:\&quot;intraday\&quot;,\&quot;limitPrice\&quot;:0,\&quot;validity\&quot;:\&quot;ioc\&quot;,\&quot;discQty\&quot;:500},{\&quot;exch\&quot;:\&quot;NFO\&quot;,\&quot;symbol\&quot;:\&quot;BANKNIFTY\&quot;,\&quot;expiry\&quot;:\&quot;2022-11-24\&quot;,\&quot;optType\&quot;:\&quot;PE\&quot;,\&quot;inst\&quot;:\&quot;OPTIDX\&quot;,\&quot;strike\&quot;:\&quot;34000\&quot;,\&quot;qty\&quot;:1500,\&quot;side\&quot;:\&quot;buy\&quot;,\&quot;type\&quot;:\&quot;market\&quot;,\&quot;product\&quot;:\&quot;delivery\&quot;,\&quot;limitPrice\&quot;:0,\&quot;validity\&quot;:\&quot;day\&quot;,\&quot;mktProt\&quot;:5}]&#x60;&#x60;&#x60;&lt;/br&gt; For equity symbol instrument must be \&quot;EQT\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async orderAuthorize(clientId: string, redirectUri: string, responseType: OrderAuthorizeResponseTypeEnum, scope: OrderAuthorizeScopeEnum, state: string, params: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.orderAuthorize(clientId, redirectUri, responseType, scope, state, params, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthorizationApi.orderAuthorize']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * This service is an updated version with 2Fa login flow.</br>This service is used to get access token for the individual app registration in the developer portal.</br>Using this api direct login is possible from any programming language
         * @summary Individual Token service
         * @param {string} authorization The value should be in the following format :&lt;/br&gt;Bearer clientID&lt;/br&gt;*ClientID refers to API key in developer portal.
         * @param {string} password 
         * @param {string} twoFa **DOB or PAN will not be accepted as 2FA from 30th September 2022 as per exchange regulations. OTP or Time based OTP should be passed for this field. To get the OTP for your client code, login into the web app &lt;a href&#x3D;\\\&#39;https://cubeplus.tradejini.com/\\\&#39; target&#x3D;\\\&#39;_blank\\\&#39; &gt;link&lt;/a&gt; and in the 2FA page, click \\\&#39;Having trouble with AppCode/TOTP\\\&#39; to see \\\&#39;Send SMS / Email OTP\\\&#39; option to generate OTP.**  **For Time based OTP, login into this &lt;a href&#x3D;\\\&#39;https://cubeplus.tradejini.com/\\\&#39; target&#x3D;\\\&#39;_blank\\\&#39; &gt;link&lt;/a&gt; and set up the Authenticator app to generate time based OTP by scanning the QR code provided under the Settings section.**
         * @param {UpdatedIndividualTokenTwoFaTypEnum} twoFaTyp **Enter the type of twoFa based on your twoFa field input.**
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatedIndividualToken(authorization: string, password: string, twoFa: string, twoFaTyp: UpdatedIndividualTokenTwoFaTypEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatedIndividualToken(authorization, password, twoFa, twoFaTyp, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthorizationApi.updatedIndividualToken']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * AuthorizationApi - factory interface
 * @export
 */
export const AuthorizationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthorizationApiFp(configuration)
    return {
        /**
         * Authorize to get oAuth code. </br><span style=\'color:red\'>This API cannot be test from this API document since it is been redirected.</span>
         * @summary Authorize
         * @param {string} clientId This field value should be the API key mentioned in the registered app. If the value is improper authorization will not be allowed.
         * @param {string} redirectUri This field value should be the redirect url mentioned in the registered app. If the value is improper authorization will not be allowed.
         * @param {AuthorizeResponseTypeEnum} responseType As per oAuth specification this value should be __\&quot;code\&quot;__
         * @param {AuthorizeScopeEnum} scope This field value should be __\&quot;general\&quot;__.
         * @param {string} state A literal string that will be return in the final redirection callback.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorize(clientId: string, redirectUri: string, responseType: AuthorizeResponseTypeEnum, scope: AuthorizeScopeEnum, state: string, options?: any): AxiosPromise<void> {
            return localVarFp.authorize(clientId, redirectUri, responseType, scope, state, options).then((request) => request(axios, basePath));
        },
        /**
         * This service is used to get access token from the code which is received from final redirection call back.
         * @summary Access token
         * @param {string} code This field value will be same as code received in the final redirection callback.
         * @param {string} clientId This field value should be the API key mentioned in the registered app. If the value is improper access token will not be generated.
         * @param {string} redirectUri This field value should be the redirect url mentioned in the registered app. If the value is improper access token will not be generated.
         * @param {string} clientSecret This field value should be the API secret provided at the app registration. If the value is improper access token will not be generated.
         * @param {GetAccessTokenGrantTypeEnum} grantType As per oAuth specification this value should be __\\\&quot;authorization_code\\\&quot;__
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessToken(code: string, clientId: string, redirectUri: string, clientSecret: string, grantType: GetAccessTokenGrantTypeEnum, options?: any): AxiosPromise<AccessToken> {
            return localVarFp.getAccessToken(code, clientId, redirectUri, clientSecret, grantType, options).then((request) => request(axios, basePath));
        },
        /**
         * Authorize to place orders and get oAuth Code to the redirect url at once.</br><span style=\'color:red\'>This API cannot be test from this API document since it is been redirected.</span>
         * @summary Order Connect [Offsite Orders]
         * @param {string} clientId This field value should be the API key mentioned in the registered app. If the value is improper authorization will not be allowed.
         * @param {string} redirectUri This field value should be the redirect url mentioned in the registered app. If the value is improper authorization will not be allowed.
         * @param {OrderAuthorizeResponseTypeEnum} responseType As per oAuth specification this value should be __\&quot;code\&quot;__
         * @param {OrderAuthorizeScopeEnum} scope This field value should be __\&quot;general\&quot;__.
         * @param {string} state A literal string that will be return in the final redirection callback.
         * @param {string} params This field value should be the params required to place orders in json array format and get oAuth Code. &lt;/br&gt;&lt;span style&#x3D;\&#39;color:red\&#39;&gt;Each array value should match any of examples provided. Else your authorization will be failed.&lt;/span&gt;&lt;/br&gt; Example :&#x60;&#x60;&#x60;[{\&quot;exch\&quot;:\&quot;NSE\&quot;,\&quot;symbol\&quot;:\&quot;ACC\&quot;,\&quot;series\&quot;:\&quot;EQ\&quot;,\&quot;inst\&quot;:\&quot;EQT\&quot;,\&quot;qty\&quot;:10,\&quot;side\&quot;:\&quot;buy\&quot;,\&quot;type\&quot;:\&quot;limit\&quot;,\&quot;product\&quot;:\&quot;intraday\&quot;,\&quot;limitPrice\&quot;:2700.55,\&quot;validity\&quot;:\&quot;day\&quot;},{\&quot;exch\&quot;:\&quot;NFO\&quot;,\&quot;symbol\&quot;:\&quot;NIFTY\&quot;,\&quot;expiry\&quot;:\&quot;2022-11-24\&quot;,\&quot;inst\&quot;:\&quot;FUTIDX\&quot;,\&quot;qty\&quot;:2000,\&quot;side\&quot;:\&quot;sell\&quot;,\&quot;type\&quot;:\&quot;market\&quot;,\&quot;product\&quot;:\&quot;intraday\&quot;,\&quot;limitPrice\&quot;:0,\&quot;validity\&quot;:\&quot;ioc\&quot;,\&quot;discQty\&quot;:500},{\&quot;exch\&quot;:\&quot;NFO\&quot;,\&quot;symbol\&quot;:\&quot;BANKNIFTY\&quot;,\&quot;expiry\&quot;:\&quot;2022-11-24\&quot;,\&quot;optType\&quot;:\&quot;PE\&quot;,\&quot;inst\&quot;:\&quot;OPTIDX\&quot;,\&quot;strike\&quot;:\&quot;34000\&quot;,\&quot;qty\&quot;:1500,\&quot;side\&quot;:\&quot;buy\&quot;,\&quot;type\&quot;:\&quot;market\&quot;,\&quot;product\&quot;:\&quot;delivery\&quot;,\&quot;limitPrice\&quot;:0,\&quot;validity\&quot;:\&quot;day\&quot;,\&quot;mktProt\&quot;:5}]&#x60;&#x60;&#x60;&lt;/br&gt; For equity symbol instrument must be \&quot;EQT\&quot;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderAuthorize(clientId: string, redirectUri: string, responseType: OrderAuthorizeResponseTypeEnum, scope: OrderAuthorizeScopeEnum, state: string, params: string, options?: any): AxiosPromise<void> {
            return localVarFp.orderAuthorize(clientId, redirectUri, responseType, scope, state, params, options).then((request) => request(axios, basePath));
        },
        /**
         * This service is an updated version with 2Fa login flow.</br>This service is used to get access token for the individual app registration in the developer portal.</br>Using this api direct login is possible from any programming language
         * @summary Individual Token service
         * @param {string} authorization The value should be in the following format :&lt;/br&gt;Bearer clientID&lt;/br&gt;*ClientID refers to API key in developer portal.
         * @param {string} password 
         * @param {string} twoFa **DOB or PAN will not be accepted as 2FA from 30th September 2022 as per exchange regulations. OTP or Time based OTP should be passed for this field. To get the OTP for your client code, login into the web app &lt;a href&#x3D;\\\&#39;https://cubeplus.tradejini.com/\\\&#39; target&#x3D;\\\&#39;_blank\\\&#39; &gt;link&lt;/a&gt; and in the 2FA page, click \\\&#39;Having trouble with AppCode/TOTP\\\&#39; to see \\\&#39;Send SMS / Email OTP\\\&#39; option to generate OTP.**  **For Time based OTP, login into this &lt;a href&#x3D;\\\&#39;https://cubeplus.tradejini.com/\\\&#39; target&#x3D;\\\&#39;_blank\\\&#39; &gt;link&lt;/a&gt; and set up the Authenticator app to generate time based OTP by scanning the QR code provided under the Settings section.**
         * @param {UpdatedIndividualTokenTwoFaTypEnum} twoFaTyp **Enter the type of twoFa based on your twoFa field input.**
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatedIndividualToken(authorization: string, password: string, twoFa: string, twoFaTyp: UpdatedIndividualTokenTwoFaTypEnum, options?: any): AxiosPromise<AccessToken> {
            return localVarFp.updatedIndividualToken(authorization, password, twoFa, twoFaTyp, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthorizationApi - object-oriented interface
 * @export
 * @class AuthorizationApi
 * @extends {BaseAPI}
 */
export class AuthorizationApi extends BaseAPI {
    /**
     * Authorize to get oAuth code. </br><span style=\'color:red\'>This API cannot be test from this API document since it is been redirected.</span>
     * @summary Authorize
     * @param {string} clientId This field value should be the API key mentioned in the registered app. If the value is improper authorization will not be allowed.
     * @param {string} redirectUri This field value should be the redirect url mentioned in the registered app. If the value is improper authorization will not be allowed.
     * @param {AuthorizeResponseTypeEnum} responseType As per oAuth specification this value should be __\&quot;code\&quot;__
     * @param {AuthorizeScopeEnum} scope This field value should be __\&quot;general\&quot;__.
     * @param {string} state A literal string that will be return in the final redirection callback.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    public authorize(clientId: string, redirectUri: string, responseType: AuthorizeResponseTypeEnum, scope: AuthorizeScopeEnum, state: string, options?: RawAxiosRequestConfig) {
        return AuthorizationApiFp(this.configuration).authorize(clientId, redirectUri, responseType, scope, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This service is used to get access token from the code which is received from final redirection call back.
     * @summary Access token
     * @param {string} code This field value will be same as code received in the final redirection callback.
     * @param {string} clientId This field value should be the API key mentioned in the registered app. If the value is improper access token will not be generated.
     * @param {string} redirectUri This field value should be the redirect url mentioned in the registered app. If the value is improper access token will not be generated.
     * @param {string} clientSecret This field value should be the API secret provided at the app registration. If the value is improper access token will not be generated.
     * @param {GetAccessTokenGrantTypeEnum} grantType As per oAuth specification this value should be __\\\&quot;authorization_code\\\&quot;__
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    public getAccessToken(code: string, clientId: string, redirectUri: string, clientSecret: string, grantType: GetAccessTokenGrantTypeEnum, options?: RawAxiosRequestConfig) {
        return AuthorizationApiFp(this.configuration).getAccessToken(code, clientId, redirectUri, clientSecret, grantType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authorize to place orders and get oAuth Code to the redirect url at once.</br><span style=\'color:red\'>This API cannot be test from this API document since it is been redirected.</span>
     * @summary Order Connect [Offsite Orders]
     * @param {string} clientId This field value should be the API key mentioned in the registered app. If the value is improper authorization will not be allowed.
     * @param {string} redirectUri This field value should be the redirect url mentioned in the registered app. If the value is improper authorization will not be allowed.
     * @param {OrderAuthorizeResponseTypeEnum} responseType As per oAuth specification this value should be __\&quot;code\&quot;__
     * @param {OrderAuthorizeScopeEnum} scope This field value should be __\&quot;general\&quot;__.
     * @param {string} state A literal string that will be return in the final redirection callback.
     * @param {string} params This field value should be the params required to place orders in json array format and get oAuth Code. &lt;/br&gt;&lt;span style&#x3D;\&#39;color:red\&#39;&gt;Each array value should match any of examples provided. Else your authorization will be failed.&lt;/span&gt;&lt;/br&gt; Example :&#x60;&#x60;&#x60;[{\&quot;exch\&quot;:\&quot;NSE\&quot;,\&quot;symbol\&quot;:\&quot;ACC\&quot;,\&quot;series\&quot;:\&quot;EQ\&quot;,\&quot;inst\&quot;:\&quot;EQT\&quot;,\&quot;qty\&quot;:10,\&quot;side\&quot;:\&quot;buy\&quot;,\&quot;type\&quot;:\&quot;limit\&quot;,\&quot;product\&quot;:\&quot;intraday\&quot;,\&quot;limitPrice\&quot;:2700.55,\&quot;validity\&quot;:\&quot;day\&quot;},{\&quot;exch\&quot;:\&quot;NFO\&quot;,\&quot;symbol\&quot;:\&quot;NIFTY\&quot;,\&quot;expiry\&quot;:\&quot;2022-11-24\&quot;,\&quot;inst\&quot;:\&quot;FUTIDX\&quot;,\&quot;qty\&quot;:2000,\&quot;side\&quot;:\&quot;sell\&quot;,\&quot;type\&quot;:\&quot;market\&quot;,\&quot;product\&quot;:\&quot;intraday\&quot;,\&quot;limitPrice\&quot;:0,\&quot;validity\&quot;:\&quot;ioc\&quot;,\&quot;discQty\&quot;:500},{\&quot;exch\&quot;:\&quot;NFO\&quot;,\&quot;symbol\&quot;:\&quot;BANKNIFTY\&quot;,\&quot;expiry\&quot;:\&quot;2022-11-24\&quot;,\&quot;optType\&quot;:\&quot;PE\&quot;,\&quot;inst\&quot;:\&quot;OPTIDX\&quot;,\&quot;strike\&quot;:\&quot;34000\&quot;,\&quot;qty\&quot;:1500,\&quot;side\&quot;:\&quot;buy\&quot;,\&quot;type\&quot;:\&quot;market\&quot;,\&quot;product\&quot;:\&quot;delivery\&quot;,\&quot;limitPrice\&quot;:0,\&quot;validity\&quot;:\&quot;day\&quot;,\&quot;mktProt\&quot;:5}]&#x60;&#x60;&#x60;&lt;/br&gt; For equity symbol instrument must be \&quot;EQT\&quot;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    public orderAuthorize(clientId: string, redirectUri: string, responseType: OrderAuthorizeResponseTypeEnum, scope: OrderAuthorizeScopeEnum, state: string, params: string, options?: RawAxiosRequestConfig) {
        return AuthorizationApiFp(this.configuration).orderAuthorize(clientId, redirectUri, responseType, scope, state, params, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * This service is an updated version with 2Fa login flow.</br>This service is used to get access token for the individual app registration in the developer portal.</br>Using this api direct login is possible from any programming language
     * @summary Individual Token service
     * @param {string} authorization The value should be in the following format :&lt;/br&gt;Bearer clientID&lt;/br&gt;*ClientID refers to API key in developer portal.
     * @param {string} password 
     * @param {string} twoFa **DOB or PAN will not be accepted as 2FA from 30th September 2022 as per exchange regulations. OTP or Time based OTP should be passed for this field. To get the OTP for your client code, login into the web app &lt;a href&#x3D;\\\&#39;https://cubeplus.tradejini.com/\\\&#39; target&#x3D;\\\&#39;_blank\\\&#39; &gt;link&lt;/a&gt; and in the 2FA page, click \\\&#39;Having trouble with AppCode/TOTP\\\&#39; to see \\\&#39;Send SMS / Email OTP\\\&#39; option to generate OTP.**  **For Time based OTP, login into this &lt;a href&#x3D;\\\&#39;https://cubeplus.tradejini.com/\\\&#39; target&#x3D;\\\&#39;_blank\\\&#39; &gt;link&lt;/a&gt; and set up the Authenticator app to generate time based OTP by scanning the QR code provided under the Settings section.**
     * @param {UpdatedIndividualTokenTwoFaTypEnum} twoFaTyp **Enter the type of twoFa based on your twoFa field input.**
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthorizationApi
     */
    public updatedIndividualToken(authorization: string, password: string, twoFa: string, twoFaTyp: UpdatedIndividualTokenTwoFaTypEnum, options?: RawAxiosRequestConfig) {
        return AuthorizationApiFp(this.configuration).updatedIndividualToken(authorization, password, twoFa, twoFaTyp, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const AuthorizeResponseTypeEnum = {
    Code: 'code'
} as const;
export type AuthorizeResponseTypeEnum = typeof AuthorizeResponseTypeEnum[keyof typeof AuthorizeResponseTypeEnum];
/**
 * @export
 */
export const AuthorizeScopeEnum = {
    General: 'general'
} as const;
export type AuthorizeScopeEnum = typeof AuthorizeScopeEnum[keyof typeof AuthorizeScopeEnum];
/**
 * @export
 */
export const GetAccessTokenGrantTypeEnum = {
    AuthorizationCode: 'authorization_code'
} as const;
export type GetAccessTokenGrantTypeEnum = typeof GetAccessTokenGrantTypeEnum[keyof typeof GetAccessTokenGrantTypeEnum];
/**
 * @export
 */
export const OrderAuthorizeResponseTypeEnum = {
    Code: 'code'
} as const;
export type OrderAuthorizeResponseTypeEnum = typeof OrderAuthorizeResponseTypeEnum[keyof typeof OrderAuthorizeResponseTypeEnum];
/**
 * @export
 */
export const OrderAuthorizeScopeEnum = {
    General: 'general'
} as const;
export type OrderAuthorizeScopeEnum = typeof OrderAuthorizeScopeEnum[keyof typeof OrderAuthorizeScopeEnum];
/**
 * @export
 */
export const UpdatedIndividualTokenTwoFaTypEnum = {
    Otp: 'otp',
    Totp: 'totp'
} as const;
export type UpdatedIndividualTokenTwoFaTypEnum = typeof UpdatedIndividualTokenTwoFaTypEnum[keyof typeof UpdatedIndividualTokenTwoFaTypEnum];


/**
 * ChartDataApi - axios parameter creator
 * @export
 */
export const ChartDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This service can be used to fetch the  open, high, low, close and volume values (chart data points) of a given symbol.</br>Also it provides sum up volume of last tick to calculate the current minute volume.</br>For derivative symbol, an additional field Open Interest Change for that particular minute will be added in same response array.
         * @summary Interval Chart
         * @param {number} from Enter starting datetime(eg: 2023-06-01 9:15:00 ) in timestamp(eg: 1685591100)
         * @param {number} to Enter ending datetime(eg: 2023-06-01 13:12:34) in timestamp(eg: 1685605354)
         * @param {GetIntervalChartDataIntervalEnum} interval Enter time interval in minutes
         * @param {string} id Enter Symbol id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntervalChartData: async (from: number, to: number, interval: GetIntervalChartDataIntervalEnum, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'from' is not null or undefined
            assertParamExists('getIntervalChartData', 'from', from)
            // verify required parameter 'to' is not null or undefined
            assertParamExists('getIntervalChartData', 'to', to)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('getIntervalChartData', 'interval', interval)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getIntervalChartData', 'id', id)
            const localVarPath = `/api/mkt-data/chart/interval-data`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http_bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (to !== undefined) {
                localVarQueryParameter['to'] = to;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChartDataApi - functional programming interface
 * @export
 */
export const ChartDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChartDataApiAxiosParamCreator(configuration)
    return {
        /**
         * This service can be used to fetch the  open, high, low, close and volume values (chart data points) of a given symbol.</br>Also it provides sum up volume of last tick to calculate the current minute volume.</br>For derivative symbol, an additional field Open Interest Change for that particular minute will be added in same response array.
         * @summary Interval Chart
         * @param {number} from Enter starting datetime(eg: 2023-06-01 9:15:00 ) in timestamp(eg: 1685591100)
         * @param {number} to Enter ending datetime(eg: 2023-06-01 13:12:34) in timestamp(eg: 1685605354)
         * @param {GetIntervalChartDataIntervalEnum} interval Enter time interval in minutes
         * @param {string} id Enter Symbol id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getIntervalChartData(from: number, to: number, interval: GetIntervalChartDataIntervalEnum, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetIntervalChartData200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getIntervalChartData(from, to, interval, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ChartDataApi.getIntervalChartData']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ChartDataApi - factory interface
 * @export
 */
export const ChartDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChartDataApiFp(configuration)
    return {
        /**
         * This service can be used to fetch the  open, high, low, close and volume values (chart data points) of a given symbol.</br>Also it provides sum up volume of last tick to calculate the current minute volume.</br>For derivative symbol, an additional field Open Interest Change for that particular minute will be added in same response array.
         * @summary Interval Chart
         * @param {number} from Enter starting datetime(eg: 2023-06-01 9:15:00 ) in timestamp(eg: 1685591100)
         * @param {number} to Enter ending datetime(eg: 2023-06-01 13:12:34) in timestamp(eg: 1685605354)
         * @param {GetIntervalChartDataIntervalEnum} interval Enter time interval in minutes
         * @param {string} id Enter Symbol id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getIntervalChartData(from: number, to: number, interval: GetIntervalChartDataIntervalEnum, id: string, options?: any): AxiosPromise<GetIntervalChartData200Response> {
            return localVarFp.getIntervalChartData(from, to, interval, id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChartDataApi - object-oriented interface
 * @export
 * @class ChartDataApi
 * @extends {BaseAPI}
 */
export class ChartDataApi extends BaseAPI {
    /**
     * This service can be used to fetch the  open, high, low, close and volume values (chart data points) of a given symbol.</br>Also it provides sum up volume of last tick to calculate the current minute volume.</br>For derivative symbol, an additional field Open Interest Change for that particular minute will be added in same response array.
     * @summary Interval Chart
     * @param {number} from Enter starting datetime(eg: 2023-06-01 9:15:00 ) in timestamp(eg: 1685591100)
     * @param {number} to Enter ending datetime(eg: 2023-06-01 13:12:34) in timestamp(eg: 1685605354)
     * @param {GetIntervalChartDataIntervalEnum} interval Enter time interval in minutes
     * @param {string} id Enter Symbol id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChartDataApi
     */
    public getIntervalChartData(from: number, to: number, interval: GetIntervalChartDataIntervalEnum, id: string, options?: RawAxiosRequestConfig) {
        return ChartDataApiFp(this.configuration).getIntervalChartData(from, to, interval, id, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetIntervalChartDataIntervalEnum = {
    _1: '1'
} as const;
export type GetIntervalChartDataIntervalEnum = typeof GetIntervalChartDataIntervalEnum[keyof typeof GetIntervalChartDataIntervalEnum];


/**
 * FundsApi - axios parameter creator
 * @export
 */
export const FundsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * to get the limits
         * @summary Limits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveFundsLimits: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/oms/limits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http_bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FundsApi - functional programming interface
 * @export
 */
export const FundsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FundsApiAxiosParamCreator(configuration)
    return {
        /**
         * to get the limits
         * @summary Limits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async retrieveFundsLimits(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RetrieveFundsLimits200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.retrieveFundsLimits(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FundsApi.retrieveFundsLimits']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * FundsApi - factory interface
 * @export
 */
export const FundsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FundsApiFp(configuration)
    return {
        /**
         * to get the limits
         * @summary Limits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        retrieveFundsLimits(options?: any): AxiosPromise<RetrieveFundsLimits200Response> {
            return localVarFp.retrieveFundsLimits(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FundsApi - object-oriented interface
 * @export
 * @class FundsApi
 * @extends {BaseAPI}
 */
export class FundsApi extends BaseAPI {
    /**
     * to get the limits
     * @summary Limits
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FundsApi
     */
    public retrieveFundsLimits(options?: RawAxiosRequestConfig) {
        return FundsApiFp(this.configuration).retrieveFundsLimits(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OrdersApi - axios parameter creator
 * @export
 */
export const OrdersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * to cancel the pending order
         * @summary Cancel Order
         * @param {string} orderId Order id of an order which needs to be cancelled. Order id is received from orders response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrder: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('cancelOrder', 'orderId', orderId)
            const localVarPath = `/api/oms/cancel-order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http_bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * to convert a position from one product type to another
         * @summary Convert Position 
         * @param {string} symId Unique identifier of the symbol
         * @param {number} qty No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.
         * @param {ConvertPositionFromProductEnum} fromProduct Current product type of a position record
         * @param {ConvertPositionToProductEnum} toProduct Product to which the user wants to convert 
         * @param {ConvertPositionSideEnum} side Order side \\\&#39;buy\\\&#39; or \\\&#39;sell\\\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        convertPosition: async (symId: string, qty: number, fromProduct: ConvertPositionFromProductEnum, toProduct: ConvertPositionToProductEnum, side: ConvertPositionSideEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symId' is not null or undefined
            assertParamExists('convertPosition', 'symId', symId)
            // verify required parameter 'qty' is not null or undefined
            assertParamExists('convertPosition', 'qty', qty)
            // verify required parameter 'fromProduct' is not null or undefined
            assertParamExists('convertPosition', 'fromProduct', fromProduct)
            // verify required parameter 'toProduct' is not null or undefined
            assertParamExists('convertPosition', 'toProduct', toProduct)
            // verify required parameter 'side' is not null or undefined
            assertParamExists('convertPosition', 'side', side)
            const localVarPath = `/api/oms/convert-position`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication http_bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (symId !== undefined) { 
                localVarFormParams.set('symId', symId as any);
            }
    
            if (qty !== undefined) { 
                localVarFormParams.set('qty', qty as any);
            }
    
            if (fromProduct !== undefined) { 
                localVarFormParams.set('fromProduct', fromProduct as any);
            }
    
            if (toProduct !== undefined) { 
                localVarFormParams.set('toProduct', toProduct as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Basket order margin
         * @summary Basket Order Margin
         * @param {BasketOrderMarginRequest} basketOrderMarginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBasketOrderMargin: async (basketOrderMarginRequest: BasketOrderMarginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'basketOrderMarginRequest' is not null or undefined
            assertParamExists('getBasketOrderMargin', 'basketOrderMarginRequest', basketOrderMarginRequest)
            const localVarPath = `/api/oms/basket-margin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http_bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(basketOrderMarginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * to get the list of holding records
         * @summary Holdings 
         * @param {boolean} [symDetails] Sending symDetails:\&#39;true\&#39; - will provide the symbol object in response for every record. Symbol object contains details such as price-tick, lotsize, token etc..,
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHoldings: async (symDetails?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/oms/holdings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http_bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (symDetails !== undefined) {
                localVarQueryParameter['symDetails'] = symDetails;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * to get an order history of an order
         * @summary History
         * @param {string} orderId Order id of an order. This will be received in orders response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderHistory: async (orderId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('getOrderHistory', 'orderId', orderId)
            const localVarPath = `/api/oms/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http_bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (orderId !== undefined) {
                localVarQueryParameter['orderId'] = orderId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * to get the margin required and available margin info while placing an order
         * @summary Order Margin
         * @param {string} symId Unique identifier of the symbol
         * @param {number} qty \\\&#39;qty\\\&#39; is number of shares for which required margin, for modification order \\\&#39;qty\\\&#39; should be \\\&#39;fillQty\\\&#39; + \\\&#39;modified qty\\\&#39; 
         * @param {GetOrderMarginSideEnum} side Order side \\\&#39;buy\\\&#39; or \\\&#39;sell\\\&#39;
         * @param {GetOrderMarginTypeEnum} type Price type of an order
         * @param {GetOrderMarginProductEnum} product Product type of an order. \\\&#39;delivery\\\&#39; is applicable for equities. \\\&#39;normal\\\&#39; is applicable for derivatives. \\\&#39;intraday\\\&#39; is applicable for both equity and derivatives
         * @param {number} [limitPrice] This is required only for limit and stop limit orders
         * @param {number} [trigPrice] This is required only for stoploss limit and stoploss market orders
         * @param {number} [stopTrigPrice] Stop loss leg order trigger price.
         * @param {number} [orgQty] Original quantity is applicable for modification order, original quantity is \\\&#39;qty\\\&#39; from orderbook
         * @param {number} [orgLimitPrice] Original limit price is applicable for modification order, original limit price is limit price from orderbook
         * @param {number} [orgTrigPrice] Original trigger price is applicable for modification order, original trigger price is trigger price from orderbook
         * @param {number} [orgStopTrigPrice] Original stop loss price is applicable only for Cover and Bracket order modification, original stop loss price is stop loss price from orderbook.
         * @param {number} [fillQty] fillQty is partially filled quantity, fillQty is \\\&#39;fillQty\\\&#39; from orderbook.
         * @param {string} [orderId] Order id is applicable for bracket and cover order modification 
         * @param {string} [mainLegOrderId] Mainleg order id field is applicable for bracket and cover order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderMargin: async (symId: string, qty: number, side: GetOrderMarginSideEnum, type: GetOrderMarginTypeEnum, product: GetOrderMarginProductEnum, limitPrice?: number, trigPrice?: number, stopTrigPrice?: number, orgQty?: number, orgLimitPrice?: number, orgTrigPrice?: number, orgStopTrigPrice?: number, fillQty?: number, orderId?: string, mainLegOrderId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symId' is not null or undefined
            assertParamExists('getOrderMargin', 'symId', symId)
            // verify required parameter 'qty' is not null or undefined
            assertParamExists('getOrderMargin', 'qty', qty)
            // verify required parameter 'side' is not null or undefined
            assertParamExists('getOrderMargin', 'side', side)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getOrderMargin', 'type', type)
            // verify required parameter 'product' is not null or undefined
            assertParamExists('getOrderMargin', 'product', product)
            const localVarPath = `/api/oms/margin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication http_bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (symId !== undefined) { 
                localVarFormParams.set('symId', symId as any);
            }
    
            if (qty !== undefined) { 
                localVarFormParams.set('qty', qty as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
            if (product !== undefined) { 
                localVarFormParams.set('product', product as any);
            }
    
            if (limitPrice !== undefined) { 
                localVarFormParams.set('limitPrice', limitPrice as any);
            }
    
            if (trigPrice !== undefined) { 
                localVarFormParams.set('trigPrice', trigPrice as any);
            }
    
            if (stopTrigPrice !== undefined) { 
                localVarFormParams.set('stopTrigPrice', stopTrigPrice as any);
            }
    
            if (orgQty !== undefined) { 
                localVarFormParams.set('orgQty', orgQty as any);
            }
    
            if (orgLimitPrice !== undefined) { 
                localVarFormParams.set('orgLimitPrice', orgLimitPrice as any);
            }
    
            if (orgTrigPrice !== undefined) { 
                localVarFormParams.set('orgTrigPrice', orgTrigPrice as any);
            }
    
            if (orgStopTrigPrice !== undefined) { 
                localVarFormParams.set('orgStopTrigPrice', orgStopTrigPrice as any);
            }
    
            if (fillQty !== undefined) { 
                localVarFormParams.set('fillQty', fillQty as any);
            }
    
            if (orderId !== undefined) { 
                localVarFormParams.set('orderId', orderId as any);
            }
    
            if (mainLegOrderId !== undefined) { 
                localVarFormParams.set('mainLegOrderId', mainLegOrderId as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * to get list of orders placed
         * @summary Orders
         * @param {boolean} [symDetails] Sending symDetails:\&#39;true\&#39; - will provide the symbol object in response for every record. Symbol object contains details such as price-tick, lotsize, token etc..,
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrders: async (symDetails?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/oms/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http_bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (symDetails !== undefined) {
                localVarQueryParameter['symDetails'] = symDetails;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * to get a list of positions records </br></br> <b>MTM Calculations:</b> <ul> <li><b>Realized:</b> realizedPnl</li> <li><b>UnRealized:</b> ( netQty * ( LTP - netAvgPrice)) * multiplier * pricefactor</li> <li><b>Total MTM:</b> Realized + UnRealized</li> </ul> <b>P&L Calculations:</b> <ul> <li><b>Realized:</b> realizedOrgPnl</li> <li><b>UnRealized:</b> ( netQty * ( LTP - netOrgAvgPrice)) * multiplier * pricefactor</li> <li><b>Total P&L:</b> Realized + UnRealized</li> </ul> <b>Day Positions - MTM Calculations:</b> <ul> <li><b>Realized:</b> dayRealizedPnl</li> <li><b>UnRealized:</b> ( dayQty * ( LTP - dayAvg)) * multiplier * pricefactor</li> <li><b>Total Day MTM:</b> Realized + UnRealized</li> </ul> <b>Note:</b> <ul> <li>For the commodity (MCX), the net quantity should be multiplied by the lot size in the above calculations.</li> <li>The LTP mentioned above should be retrieved from real-time updates via the streaming SDK</li> </ul>
         * @summary Positions 
         * @param {boolean} [symDetails] Sending symDetails:\&#39;true\&#39; - will provide the symbol object in response for every record. Symbol object contains details such as price-tick, lotsize, token etc..,
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPositions: async (symDetails?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/oms/positions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http_bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (symDetails !== undefined) {
                localVarQueryParameter['symDetails'] = symDetails;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * to get a list of trade records
         * @summary Trades
         * @param {boolean} [symDetails] Sending symDetails:\&#39;true\&#39; - will provide the symbol object in response for every record. Symbol object contains details such as price-tick, lotsize, token etc..,
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrades: async (symDetails?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/oms/trades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication http_bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (symDetails !== undefined) {
                localVarQueryParameter['symDetails'] = symDetails;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * to modify the pending order
         * @summary Modify Order
         * @param {string} symId Unique identifier of the symbol
         * @param {string} orderId Order id of an order which needs modification. This id will be received in orders service
         * @param {number} qty Total order quantity after the modification. ( Filled Qty (if nonzero) + (Modified Qty or Pending Qty)). Example: If the order quantity is 100, out of that 60 is already filled, and if we are modifying the pending qty from 40 to 70 then qty &#x3D;&gt; (60 + 70) &#x3D; 130 should be sent. 
         * @param {ModifyOrderTypeEnum} type Price type of an order
         * @param {ModifyOrderValidityEnum} validity Validity of an order, EOS is applicable for BSE scrips only
         * @param {number} [limitPrice] This is required only for limit and stop limit orders
         * @param {number} [trigPrice] This is required only for stoploss limit and stoploss market orders
         * @param {number} [discQty] Disclosed quantity of an order
         * @param {number} [mktProt] Market order protection percentage. Applicable only for market orders
         * @param {ModifyOrderSideEnum} [side] Order side \\\&#39;buy\\\&#39; or \\\&#39;sell\\\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyOrder: async (symId: string, orderId: string, qty: number, type: ModifyOrderTypeEnum, validity: ModifyOrderValidityEnum, limitPrice?: number, trigPrice?: number, discQty?: number, mktProt?: number, side?: ModifyOrderSideEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symId' is not null or undefined
            assertParamExists('modifyOrder', 'symId', symId)
            // verify required parameter 'orderId' is not null or undefined
            assertParamExists('modifyOrder', 'orderId', orderId)
            // verify required parameter 'qty' is not null or undefined
            assertParamExists('modifyOrder', 'qty', qty)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('modifyOrder', 'type', type)
            // verify required parameter 'validity' is not null or undefined
            assertParamExists('modifyOrder', 'validity', validity)
            const localVarPath = `/api/oms/modify-order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication http_bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (symId !== undefined) { 
                localVarFormParams.set('symId', symId as any);
            }
    
            if (orderId !== undefined) { 
                localVarFormParams.set('orderId', orderId as any);
            }
    
            if (qty !== undefined) { 
                localVarFormParams.set('qty', qty as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
            if (limitPrice !== undefined) { 
                localVarFormParams.set('limitPrice', limitPrice as any);
            }
    
            if (trigPrice !== undefined) { 
                localVarFormParams.set('trigPrice', trigPrice as any);
            }
    
            if (validity !== undefined) { 
                localVarFormParams.set('validity', validity as any);
            }
    
            if (discQty !== undefined) { 
                localVarFormParams.set('discQty', discQty as any);
            }
    
            if (mktProt !== undefined) { 
                localVarFormParams.set('mktProt', mktProt as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * to place the order
         * @summary Place Order
         * @param {string} symId Unique identifier of the symbol
         * @param {number} qty No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.
         * @param {PlaceOrderSideEnum} side Order side \\\&#39;buy\\\&#39; or \\\&#39;sell\\\&#39;
         * @param {PlaceOrderTypeEnum} type Price type of an order
         * @param {PlaceOrderProductEnum} product Product type of an order. \\\&#39;delivery\\\&#39; is applicable for equities. \\\&#39;normal\\\&#39; is applicable for derivatives. \\\&#39;intraday\\\&#39; is applicable for both equity and derivatives
         * @param {PlaceOrderValidityEnum} validity Validity of an order, EOS is applicable for BSE scrips only
         * @param {number} [limitPrice] This is required only for limit and stop limit orders
         * @param {number} [trigPrice] This is required only for stoploss limit and stoploss market orders
         * @param {number} [discQty] Disclosed quantity of an order
         * @param {boolean} [amo] Pass this field as true to place an amo order.
         * @param {number} [mktProt] Market order protection percentage. Applicable only for market orders
         * @param {string} [remarks] Any tag or message to track in orderbook.Allowed length upto 10 Characters. Please note remarks more than 10 characters will be stripped out.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeOrder: async (symId: string, qty: number, side: PlaceOrderSideEnum, type: PlaceOrderTypeEnum, product: PlaceOrderProductEnum, validity: PlaceOrderValidityEnum, limitPrice?: number, trigPrice?: number, discQty?: number, amo?: boolean, mktProt?: number, remarks?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symId' is not null or undefined
            assertParamExists('placeOrder', 'symId', symId)
            // verify required parameter 'qty' is not null or undefined
            assertParamExists('placeOrder', 'qty', qty)
            // verify required parameter 'side' is not null or undefined
            assertParamExists('placeOrder', 'side', side)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('placeOrder', 'type', type)
            // verify required parameter 'product' is not null or undefined
            assertParamExists('placeOrder', 'product', product)
            // verify required parameter 'validity' is not null or undefined
            assertParamExists('placeOrder', 'validity', validity)
            const localVarPath = `/api/oms/place-order`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();

            // authentication http_bearer required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (symId !== undefined) { 
                localVarFormParams.set('symId', symId as any);
            }
    
            if (qty !== undefined) { 
                localVarFormParams.set('qty', qty as any);
            }
    
            if (side !== undefined) { 
                localVarFormParams.set('side', side as any);
            }
    
            if (type !== undefined) { 
                localVarFormParams.set('type', type as any);
            }
    
            if (product !== undefined) { 
                localVarFormParams.set('product', product as any);
            }
    
            if (limitPrice !== undefined) { 
                localVarFormParams.set('limitPrice', limitPrice as any);
            }
    
            if (trigPrice !== undefined) { 
                localVarFormParams.set('trigPrice', trigPrice as any);
            }
    
            if (validity !== undefined) { 
                localVarFormParams.set('validity', validity as any);
            }
    
            if (discQty !== undefined) { 
                localVarFormParams.set('discQty', discQty as any);
            }
    
            if (amo !== undefined) { 
                localVarFormParams.set('amo', amo as any);
            }
    
            if (mktProt !== undefined) { 
                localVarFormParams.set('mktProt', mktProt as any);
            }
    
            if (remarks !== undefined) { 
                localVarFormParams.set('remarks', remarks as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrdersApi - functional programming interface
 * @export
 */
export const OrdersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrdersApiAxiosParamCreator(configuration)
    return {
        /**
         * to cancel the pending order
         * @summary Cancel Order
         * @param {string} orderId Order id of an order which needs to be cancelled. Order id is received from orders response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelOrder(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CancelOrder200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelOrder(orderId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OrdersApi.cancelOrder']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * to convert a position from one product type to another
         * @summary Convert Position 
         * @param {string} symId Unique identifier of the symbol
         * @param {number} qty No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.
         * @param {ConvertPositionFromProductEnum} fromProduct Current product type of a position record
         * @param {ConvertPositionToProductEnum} toProduct Product to which the user wants to convert 
         * @param {ConvertPositionSideEnum} side Order side \\\&#39;buy\\\&#39; or \\\&#39;sell\\\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async convertPosition(symId: string, qty: number, fromProduct: ConvertPositionFromProductEnum, toProduct: ConvertPositionToProductEnum, side: ConvertPositionSideEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConvertPosition200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.convertPosition(symId, qty, fromProduct, toProduct, side, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OrdersApi.convertPosition']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Basket order margin
         * @summary Basket Order Margin
         * @param {BasketOrderMarginRequest} basketOrderMarginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBasketOrderMargin(basketOrderMarginRequest: BasketOrderMarginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetBasketOrderMargin200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBasketOrderMargin(basketOrderMarginRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OrdersApi.getBasketOrderMargin']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * to get the list of holding records
         * @summary Holdings 
         * @param {boolean} [symDetails] Sending symDetails:\&#39;true\&#39; - will provide the symbol object in response for every record. Symbol object contains details such as price-tick, lotsize, token etc..,
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHoldings(symDetails?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetHoldings200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHoldings(symDetails, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OrdersApi.getHoldings']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * to get an order history of an order
         * @summary History
         * @param {string} orderId Order id of an order. This will be received in orders response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderHistory(orderId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrderHistory200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderHistory(orderId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OrdersApi.getOrderHistory']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * to get the margin required and available margin info while placing an order
         * @summary Order Margin
         * @param {string} symId Unique identifier of the symbol
         * @param {number} qty \\\&#39;qty\\\&#39; is number of shares for which required margin, for modification order \\\&#39;qty\\\&#39; should be \\\&#39;fillQty\\\&#39; + \\\&#39;modified qty\\\&#39; 
         * @param {GetOrderMarginSideEnum} side Order side \\\&#39;buy\\\&#39; or \\\&#39;sell\\\&#39;
         * @param {GetOrderMarginTypeEnum} type Price type of an order
         * @param {GetOrderMarginProductEnum} product Product type of an order. \\\&#39;delivery\\\&#39; is applicable for equities. \\\&#39;normal\\\&#39; is applicable for derivatives. \\\&#39;intraday\\\&#39; is applicable for both equity and derivatives
         * @param {number} [limitPrice] This is required only for limit and stop limit orders
         * @param {number} [trigPrice] This is required only for stoploss limit and stoploss market orders
         * @param {number} [stopTrigPrice] Stop loss leg order trigger price.
         * @param {number} [orgQty] Original quantity is applicable for modification order, original quantity is \\\&#39;qty\\\&#39; from orderbook
         * @param {number} [orgLimitPrice] Original limit price is applicable for modification order, original limit price is limit price from orderbook
         * @param {number} [orgTrigPrice] Original trigger price is applicable for modification order, original trigger price is trigger price from orderbook
         * @param {number} [orgStopTrigPrice] Original stop loss price is applicable only for Cover and Bracket order modification, original stop loss price is stop loss price from orderbook.
         * @param {number} [fillQty] fillQty is partially filled quantity, fillQty is \\\&#39;fillQty\\\&#39; from orderbook.
         * @param {string} [orderId] Order id is applicable for bracket and cover order modification 
         * @param {string} [mainLegOrderId] Mainleg order id field is applicable for bracket and cover order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderMargin(symId: string, qty: number, side: GetOrderMarginSideEnum, type: GetOrderMarginTypeEnum, product: GetOrderMarginProductEnum, limitPrice?: number, trigPrice?: number, stopTrigPrice?: number, orgQty?: number, orgLimitPrice?: number, orgTrigPrice?: number, orgStopTrigPrice?: number, fillQty?: number, orderId?: string, mainLegOrderId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrderMargin200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderMargin(symId, qty, side, type, product, limitPrice, trigPrice, stopTrigPrice, orgQty, orgLimitPrice, orgTrigPrice, orgStopTrigPrice, fillQty, orderId, mainLegOrderId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OrdersApi.getOrderMargin']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * to get list of orders placed
         * @summary Orders
         * @param {boolean} [symDetails] Sending symDetails:\&#39;true\&#39; - will provide the symbol object in response for every record. Symbol object contains details such as price-tick, lotsize, token etc..,
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrders(symDetails?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetOrders200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrders(symDetails, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OrdersApi.getOrders']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * to get a list of positions records </br></br> <b>MTM Calculations:</b> <ul> <li><b>Realized:</b> realizedPnl</li> <li><b>UnRealized:</b> ( netQty * ( LTP - netAvgPrice)) * multiplier * pricefactor</li> <li><b>Total MTM:</b> Realized + UnRealized</li> </ul> <b>P&L Calculations:</b> <ul> <li><b>Realized:</b> realizedOrgPnl</li> <li><b>UnRealized:</b> ( netQty * ( LTP - netOrgAvgPrice)) * multiplier * pricefactor</li> <li><b>Total P&L:</b> Realized + UnRealized</li> </ul> <b>Day Positions - MTM Calculations:</b> <ul> <li><b>Realized:</b> dayRealizedPnl</li> <li><b>UnRealized:</b> ( dayQty * ( LTP - dayAvg)) * multiplier * pricefactor</li> <li><b>Total Day MTM:</b> Realized + UnRealized</li> </ul> <b>Note:</b> <ul> <li>For the commodity (MCX), the net quantity should be multiplied by the lot size in the above calculations.</li> <li>The LTP mentioned above should be retrieved from real-time updates via the streaming SDK</li> </ul>
         * @summary Positions 
         * @param {boolean} [symDetails] Sending symDetails:\&#39;true\&#39; - will provide the symbol object in response for every record. Symbol object contains details such as price-tick, lotsize, token etc..,
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPositions(symDetails?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPositions200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPositions(symDetails, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OrdersApi.getPositions']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * to get a list of trade records
         * @summary Trades
         * @param {boolean} [symDetails] Sending symDetails:\&#39;true\&#39; - will provide the symbol object in response for every record. Symbol object contains details such as price-tick, lotsize, token etc..,
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTrades(symDetails?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTrades200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTrades(symDetails, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OrdersApi.getTrades']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * to modify the pending order
         * @summary Modify Order
         * @param {string} symId Unique identifier of the symbol
         * @param {string} orderId Order id of an order which needs modification. This id will be received in orders service
         * @param {number} qty Total order quantity after the modification. ( Filled Qty (if nonzero) + (Modified Qty or Pending Qty)). Example: If the order quantity is 100, out of that 60 is already filled, and if we are modifying the pending qty from 40 to 70 then qty &#x3D;&gt; (60 + 70) &#x3D; 130 should be sent. 
         * @param {ModifyOrderTypeEnum} type Price type of an order
         * @param {ModifyOrderValidityEnum} validity Validity of an order, EOS is applicable for BSE scrips only
         * @param {number} [limitPrice] This is required only for limit and stop limit orders
         * @param {number} [trigPrice] This is required only for stoploss limit and stoploss market orders
         * @param {number} [discQty] Disclosed quantity of an order
         * @param {number} [mktProt] Market order protection percentage. Applicable only for market orders
         * @param {ModifyOrderSideEnum} [side] Order side \\\&#39;buy\\\&#39; or \\\&#39;sell\\\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async modifyOrder(symId: string, orderId: string, qty: number, type: ModifyOrderTypeEnum, validity: ModifyOrderValidityEnum, limitPrice?: number, trigPrice?: number, discQty?: number, mktProt?: number, side?: ModifyOrderSideEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ModifyOrder200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.modifyOrder(symId, orderId, qty, type, validity, limitPrice, trigPrice, discQty, mktProt, side, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OrdersApi.modifyOrder']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * to place the order
         * @summary Place Order
         * @param {string} symId Unique identifier of the symbol
         * @param {number} qty No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.
         * @param {PlaceOrderSideEnum} side Order side \\\&#39;buy\\\&#39; or \\\&#39;sell\\\&#39;
         * @param {PlaceOrderTypeEnum} type Price type of an order
         * @param {PlaceOrderProductEnum} product Product type of an order. \\\&#39;delivery\\\&#39; is applicable for equities. \\\&#39;normal\\\&#39; is applicable for derivatives. \\\&#39;intraday\\\&#39; is applicable for both equity and derivatives
         * @param {PlaceOrderValidityEnum} validity Validity of an order, EOS is applicable for BSE scrips only
         * @param {number} [limitPrice] This is required only for limit and stop limit orders
         * @param {number} [trigPrice] This is required only for stoploss limit and stoploss market orders
         * @param {number} [discQty] Disclosed quantity of an order
         * @param {boolean} [amo] Pass this field as true to place an amo order.
         * @param {number} [mktProt] Market order protection percentage. Applicable only for market orders
         * @param {string} [remarks] Any tag or message to track in orderbook.Allowed length upto 10 Characters. Please note remarks more than 10 characters will be stripped out.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async placeOrder(symId: string, qty: number, side: PlaceOrderSideEnum, type: PlaceOrderTypeEnum, product: PlaceOrderProductEnum, validity: PlaceOrderValidityEnum, limitPrice?: number, trigPrice?: number, discQty?: number, amo?: boolean, mktProt?: number, remarks?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaceOrder200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.placeOrder(symId, qty, side, type, product, validity, limitPrice, trigPrice, discQty, amo, mktProt, remarks, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OrdersApi.placeOrder']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OrdersApi - factory interface
 * @export
 */
export const OrdersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrdersApiFp(configuration)
    return {
        /**
         * to cancel the pending order
         * @summary Cancel Order
         * @param {string} orderId Order id of an order which needs to be cancelled. Order id is received from orders response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrder(orderId: string, options?: any): AxiosPromise<CancelOrder200Response> {
            return localVarFp.cancelOrder(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * to convert a position from one product type to another
         * @summary Convert Position 
         * @param {string} symId Unique identifier of the symbol
         * @param {number} qty No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.
         * @param {ConvertPositionFromProductEnum} fromProduct Current product type of a position record
         * @param {ConvertPositionToProductEnum} toProduct Product to which the user wants to convert 
         * @param {ConvertPositionSideEnum} side Order side \\\&#39;buy\\\&#39; or \\\&#39;sell\\\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        convertPosition(symId: string, qty: number, fromProduct: ConvertPositionFromProductEnum, toProduct: ConvertPositionToProductEnum, side: ConvertPositionSideEnum, options?: any): AxiosPromise<ConvertPosition200Response> {
            return localVarFp.convertPosition(symId, qty, fromProduct, toProduct, side, options).then((request) => request(axios, basePath));
        },
        /**
         * Basket order margin
         * @summary Basket Order Margin
         * @param {BasketOrderMarginRequest} basketOrderMarginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBasketOrderMargin(basketOrderMarginRequest: BasketOrderMarginRequest, options?: any): AxiosPromise<GetBasketOrderMargin200Response> {
            return localVarFp.getBasketOrderMargin(basketOrderMarginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * to get the list of holding records
         * @summary Holdings 
         * @param {boolean} [symDetails] Sending symDetails:\&#39;true\&#39; - will provide the symbol object in response for every record. Symbol object contains details such as price-tick, lotsize, token etc..,
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHoldings(symDetails?: boolean, options?: any): AxiosPromise<GetHoldings200Response> {
            return localVarFp.getHoldings(symDetails, options).then((request) => request(axios, basePath));
        },
        /**
         * to get an order history of an order
         * @summary History
         * @param {string} orderId Order id of an order. This will be received in orders response
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderHistory(orderId: string, options?: any): AxiosPromise<GetOrderHistory200Response> {
            return localVarFp.getOrderHistory(orderId, options).then((request) => request(axios, basePath));
        },
        /**
         * to get the margin required and available margin info while placing an order
         * @summary Order Margin
         * @param {string} symId Unique identifier of the symbol
         * @param {number} qty \\\&#39;qty\\\&#39; is number of shares for which required margin, for modification order \\\&#39;qty\\\&#39; should be \\\&#39;fillQty\\\&#39; + \\\&#39;modified qty\\\&#39; 
         * @param {GetOrderMarginSideEnum} side Order side \\\&#39;buy\\\&#39; or \\\&#39;sell\\\&#39;
         * @param {GetOrderMarginTypeEnum} type Price type of an order
         * @param {GetOrderMarginProductEnum} product Product type of an order. \\\&#39;delivery\\\&#39; is applicable for equities. \\\&#39;normal\\\&#39; is applicable for derivatives. \\\&#39;intraday\\\&#39; is applicable for both equity and derivatives
         * @param {number} [limitPrice] This is required only for limit and stop limit orders
         * @param {number} [trigPrice] This is required only for stoploss limit and stoploss market orders
         * @param {number} [stopTrigPrice] Stop loss leg order trigger price.
         * @param {number} [orgQty] Original quantity is applicable for modification order, original quantity is \\\&#39;qty\\\&#39; from orderbook
         * @param {number} [orgLimitPrice] Original limit price is applicable for modification order, original limit price is limit price from orderbook
         * @param {number} [orgTrigPrice] Original trigger price is applicable for modification order, original trigger price is trigger price from orderbook
         * @param {number} [orgStopTrigPrice] Original stop loss price is applicable only for Cover and Bracket order modification, original stop loss price is stop loss price from orderbook.
         * @param {number} [fillQty] fillQty is partially filled quantity, fillQty is \\\&#39;fillQty\\\&#39; from orderbook.
         * @param {string} [orderId] Order id is applicable for bracket and cover order modification 
         * @param {string} [mainLegOrderId] Mainleg order id field is applicable for bracket and cover order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderMargin(symId: string, qty: number, side: GetOrderMarginSideEnum, type: GetOrderMarginTypeEnum, product: GetOrderMarginProductEnum, limitPrice?: number, trigPrice?: number, stopTrigPrice?: number, orgQty?: number, orgLimitPrice?: number, orgTrigPrice?: number, orgStopTrigPrice?: number, fillQty?: number, orderId?: string, mainLegOrderId?: string, options?: any): AxiosPromise<GetOrderMargin200Response> {
            return localVarFp.getOrderMargin(symId, qty, side, type, product, limitPrice, trigPrice, stopTrigPrice, orgQty, orgLimitPrice, orgTrigPrice, orgStopTrigPrice, fillQty, orderId, mainLegOrderId, options).then((request) => request(axios, basePath));
        },
        /**
         * to get list of orders placed
         * @summary Orders
         * @param {boolean} [symDetails] Sending symDetails:\&#39;true\&#39; - will provide the symbol object in response for every record. Symbol object contains details such as price-tick, lotsize, token etc..,
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrders(symDetails?: boolean, options?: any): AxiosPromise<GetOrders200Response> {
            return localVarFp.getOrders(symDetails, options).then((request) => request(axios, basePath));
        },
        /**
         * to get a list of positions records </br></br> <b>MTM Calculations:</b> <ul> <li><b>Realized:</b> realizedPnl</li> <li><b>UnRealized:</b> ( netQty * ( LTP - netAvgPrice)) * multiplier * pricefactor</li> <li><b>Total MTM:</b> Realized + UnRealized</li> </ul> <b>P&L Calculations:</b> <ul> <li><b>Realized:</b> realizedOrgPnl</li> <li><b>UnRealized:</b> ( netQty * ( LTP - netOrgAvgPrice)) * multiplier * pricefactor</li> <li><b>Total P&L:</b> Realized + UnRealized</li> </ul> <b>Day Positions - MTM Calculations:</b> <ul> <li><b>Realized:</b> dayRealizedPnl</li> <li><b>UnRealized:</b> ( dayQty * ( LTP - dayAvg)) * multiplier * pricefactor</li> <li><b>Total Day MTM:</b> Realized + UnRealized</li> </ul> <b>Note:</b> <ul> <li>For the commodity (MCX), the net quantity should be multiplied by the lot size in the above calculations.</li> <li>The LTP mentioned above should be retrieved from real-time updates via the streaming SDK</li> </ul>
         * @summary Positions 
         * @param {boolean} [symDetails] Sending symDetails:\&#39;true\&#39; - will provide the symbol object in response for every record. Symbol object contains details such as price-tick, lotsize, token etc..,
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPositions(symDetails?: boolean, options?: any): AxiosPromise<GetPositions200Response> {
            return localVarFp.getPositions(symDetails, options).then((request) => request(axios, basePath));
        },
        /**
         * to get a list of trade records
         * @summary Trades
         * @param {boolean} [symDetails] Sending symDetails:\&#39;true\&#39; - will provide the symbol object in response for every record. Symbol object contains details such as price-tick, lotsize, token etc..,
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTrades(symDetails?: boolean, options?: any): AxiosPromise<GetTrades200Response> {
            return localVarFp.getTrades(symDetails, options).then((request) => request(axios, basePath));
        },
        /**
         * to modify the pending order
         * @summary Modify Order
         * @param {string} symId Unique identifier of the symbol
         * @param {string} orderId Order id of an order which needs modification. This id will be received in orders service
         * @param {number} qty Total order quantity after the modification. ( Filled Qty (if nonzero) + (Modified Qty or Pending Qty)). Example: If the order quantity is 100, out of that 60 is already filled, and if we are modifying the pending qty from 40 to 70 then qty &#x3D;&gt; (60 + 70) &#x3D; 130 should be sent. 
         * @param {ModifyOrderTypeEnum} type Price type of an order
         * @param {ModifyOrderValidityEnum} validity Validity of an order, EOS is applicable for BSE scrips only
         * @param {number} [limitPrice] This is required only for limit and stop limit orders
         * @param {number} [trigPrice] This is required only for stoploss limit and stoploss market orders
         * @param {number} [discQty] Disclosed quantity of an order
         * @param {number} [mktProt] Market order protection percentage. Applicable only for market orders
         * @param {ModifyOrderSideEnum} [side] Order side \\\&#39;buy\\\&#39; or \\\&#39;sell\\\&#39;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        modifyOrder(symId: string, orderId: string, qty: number, type: ModifyOrderTypeEnum, validity: ModifyOrderValidityEnum, limitPrice?: number, trigPrice?: number, discQty?: number, mktProt?: number, side?: ModifyOrderSideEnum, options?: any): AxiosPromise<ModifyOrder200Response> {
            return localVarFp.modifyOrder(symId, orderId, qty, type, validity, limitPrice, trigPrice, discQty, mktProt, side, options).then((request) => request(axios, basePath));
        },
        /**
         * to place the order
         * @summary Place Order
         * @param {string} symId Unique identifier of the symbol
         * @param {number} qty No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.
         * @param {PlaceOrderSideEnum} side Order side \\\&#39;buy\\\&#39; or \\\&#39;sell\\\&#39;
         * @param {PlaceOrderTypeEnum} type Price type of an order
         * @param {PlaceOrderProductEnum} product Product type of an order. \\\&#39;delivery\\\&#39; is applicable for equities. \\\&#39;normal\\\&#39; is applicable for derivatives. \\\&#39;intraday\\\&#39; is applicable for both equity and derivatives
         * @param {PlaceOrderValidityEnum} validity Validity of an order, EOS is applicable for BSE scrips only
         * @param {number} [limitPrice] This is required only for limit and stop limit orders
         * @param {number} [trigPrice] This is required only for stoploss limit and stoploss market orders
         * @param {number} [discQty] Disclosed quantity of an order
         * @param {boolean} [amo] Pass this field as true to place an amo order.
         * @param {number} [mktProt] Market order protection percentage. Applicable only for market orders
         * @param {string} [remarks] Any tag or message to track in orderbook.Allowed length upto 10 Characters. Please note remarks more than 10 characters will be stripped out.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeOrder(symId: string, qty: number, side: PlaceOrderSideEnum, type: PlaceOrderTypeEnum, product: PlaceOrderProductEnum, validity: PlaceOrderValidityEnum, limitPrice?: number, trigPrice?: number, discQty?: number, amo?: boolean, mktProt?: number, remarks?: string, options?: any): AxiosPromise<PlaceOrder200Response> {
            return localVarFp.placeOrder(symId, qty, side, type, product, validity, limitPrice, trigPrice, discQty, amo, mktProt, remarks, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrdersApi - object-oriented interface
 * @export
 * @class OrdersApi
 * @extends {BaseAPI}
 */
export class OrdersApi extends BaseAPI {
    /**
     * to cancel the pending order
     * @summary Cancel Order
     * @param {string} orderId Order id of an order which needs to be cancelled. Order id is received from orders response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public cancelOrder(orderId: string, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).cancelOrder(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * to convert a position from one product type to another
     * @summary Convert Position 
     * @param {string} symId Unique identifier of the symbol
     * @param {number} qty No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.
     * @param {ConvertPositionFromProductEnum} fromProduct Current product type of a position record
     * @param {ConvertPositionToProductEnum} toProduct Product to which the user wants to convert 
     * @param {ConvertPositionSideEnum} side Order side \\\&#39;buy\\\&#39; or \\\&#39;sell\\\&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public convertPosition(symId: string, qty: number, fromProduct: ConvertPositionFromProductEnum, toProduct: ConvertPositionToProductEnum, side: ConvertPositionSideEnum, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).convertPosition(symId, qty, fromProduct, toProduct, side, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Basket order margin
     * @summary Basket Order Margin
     * @param {BasketOrderMarginRequest} basketOrderMarginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public getBasketOrderMargin(basketOrderMarginRequest: BasketOrderMarginRequest, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).getBasketOrderMargin(basketOrderMarginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * to get the list of holding records
     * @summary Holdings 
     * @param {boolean} [symDetails] Sending symDetails:\&#39;true\&#39; - will provide the symbol object in response for every record. Symbol object contains details such as price-tick, lotsize, token etc..,
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public getHoldings(symDetails?: boolean, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).getHoldings(symDetails, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * to get an order history of an order
     * @summary History
     * @param {string} orderId Order id of an order. This will be received in orders response
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public getOrderHistory(orderId: string, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).getOrderHistory(orderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * to get the margin required and available margin info while placing an order
     * @summary Order Margin
     * @param {string} symId Unique identifier of the symbol
     * @param {number} qty \\\&#39;qty\\\&#39; is number of shares for which required margin, for modification order \\\&#39;qty\\\&#39; should be \\\&#39;fillQty\\\&#39; + \\\&#39;modified qty\\\&#39; 
     * @param {GetOrderMarginSideEnum} side Order side \\\&#39;buy\\\&#39; or \\\&#39;sell\\\&#39;
     * @param {GetOrderMarginTypeEnum} type Price type of an order
     * @param {GetOrderMarginProductEnum} product Product type of an order. \\\&#39;delivery\\\&#39; is applicable for equities. \\\&#39;normal\\\&#39; is applicable for derivatives. \\\&#39;intraday\\\&#39; is applicable for both equity and derivatives
     * @param {number} [limitPrice] This is required only for limit and stop limit orders
     * @param {number} [trigPrice] This is required only for stoploss limit and stoploss market orders
     * @param {number} [stopTrigPrice] Stop loss leg order trigger price.
     * @param {number} [orgQty] Original quantity is applicable for modification order, original quantity is \\\&#39;qty\\\&#39; from orderbook
     * @param {number} [orgLimitPrice] Original limit price is applicable for modification order, original limit price is limit price from orderbook
     * @param {number} [orgTrigPrice] Original trigger price is applicable for modification order, original trigger price is trigger price from orderbook
     * @param {number} [orgStopTrigPrice] Original stop loss price is applicable only for Cover and Bracket order modification, original stop loss price is stop loss price from orderbook.
     * @param {number} [fillQty] fillQty is partially filled quantity, fillQty is \\\&#39;fillQty\\\&#39; from orderbook.
     * @param {string} [orderId] Order id is applicable for bracket and cover order modification 
     * @param {string} [mainLegOrderId] Mainleg order id field is applicable for bracket and cover order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public getOrderMargin(symId: string, qty: number, side: GetOrderMarginSideEnum, type: GetOrderMarginTypeEnum, product: GetOrderMarginProductEnum, limitPrice?: number, trigPrice?: number, stopTrigPrice?: number, orgQty?: number, orgLimitPrice?: number, orgTrigPrice?: number, orgStopTrigPrice?: number, fillQty?: number, orderId?: string, mainLegOrderId?: string, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).getOrderMargin(symId, qty, side, type, product, limitPrice, trigPrice, stopTrigPrice, orgQty, orgLimitPrice, orgTrigPrice, orgStopTrigPrice, fillQty, orderId, mainLegOrderId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * to get list of orders placed
     * @summary Orders
     * @param {boolean} [symDetails] Sending symDetails:\&#39;true\&#39; - will provide the symbol object in response for every record. Symbol object contains details such as price-tick, lotsize, token etc..,
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public getOrders(symDetails?: boolean, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).getOrders(symDetails, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * to get a list of positions records </br></br> <b>MTM Calculations:</b> <ul> <li><b>Realized:</b> realizedPnl</li> <li><b>UnRealized:</b> ( netQty * ( LTP - netAvgPrice)) * multiplier * pricefactor</li> <li><b>Total MTM:</b> Realized + UnRealized</li> </ul> <b>P&L Calculations:</b> <ul> <li><b>Realized:</b> realizedOrgPnl</li> <li><b>UnRealized:</b> ( netQty * ( LTP - netOrgAvgPrice)) * multiplier * pricefactor</li> <li><b>Total P&L:</b> Realized + UnRealized</li> </ul> <b>Day Positions - MTM Calculations:</b> <ul> <li><b>Realized:</b> dayRealizedPnl</li> <li><b>UnRealized:</b> ( dayQty * ( LTP - dayAvg)) * multiplier * pricefactor</li> <li><b>Total Day MTM:</b> Realized + UnRealized</li> </ul> <b>Note:</b> <ul> <li>For the commodity (MCX), the net quantity should be multiplied by the lot size in the above calculations.</li> <li>The LTP mentioned above should be retrieved from real-time updates via the streaming SDK</li> </ul>
     * @summary Positions 
     * @param {boolean} [symDetails] Sending symDetails:\&#39;true\&#39; - will provide the symbol object in response for every record. Symbol object contains details such as price-tick, lotsize, token etc..,
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public getPositions(symDetails?: boolean, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).getPositions(symDetails, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * to get a list of trade records
     * @summary Trades
     * @param {boolean} [symDetails] Sending symDetails:\&#39;true\&#39; - will provide the symbol object in response for every record. Symbol object contains details such as price-tick, lotsize, token etc..,
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public getTrades(symDetails?: boolean, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).getTrades(symDetails, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * to modify the pending order
     * @summary Modify Order
     * @param {string} symId Unique identifier of the symbol
     * @param {string} orderId Order id of an order which needs modification. This id will be received in orders service
     * @param {number} qty Total order quantity after the modification. ( Filled Qty (if nonzero) + (Modified Qty or Pending Qty)). Example: If the order quantity is 100, out of that 60 is already filled, and if we are modifying the pending qty from 40 to 70 then qty &#x3D;&gt; (60 + 70) &#x3D; 130 should be sent. 
     * @param {ModifyOrderTypeEnum} type Price type of an order
     * @param {ModifyOrderValidityEnum} validity Validity of an order, EOS is applicable for BSE scrips only
     * @param {number} [limitPrice] This is required only for limit and stop limit orders
     * @param {number} [trigPrice] This is required only for stoploss limit and stoploss market orders
     * @param {number} [discQty] Disclosed quantity of an order
     * @param {number} [mktProt] Market order protection percentage. Applicable only for market orders
     * @param {ModifyOrderSideEnum} [side] Order side \\\&#39;buy\\\&#39; or \\\&#39;sell\\\&#39;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public modifyOrder(symId: string, orderId: string, qty: number, type: ModifyOrderTypeEnum, validity: ModifyOrderValidityEnum, limitPrice?: number, trigPrice?: number, discQty?: number, mktProt?: number, side?: ModifyOrderSideEnum, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).modifyOrder(symId, orderId, qty, type, validity, limitPrice, trigPrice, discQty, mktProt, side, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * to place the order
     * @summary Place Order
     * @param {string} symId Unique identifier of the symbol
     * @param {number} qty No of shares to buy or sell. For derivatives, pass the quantity by multiplying with lot size. Example: To buy 1 lot of NIFTY option, pass the quantity as 50.
     * @param {PlaceOrderSideEnum} side Order side \\\&#39;buy\\\&#39; or \\\&#39;sell\\\&#39;
     * @param {PlaceOrderTypeEnum} type Price type of an order
     * @param {PlaceOrderProductEnum} product Product type of an order. \\\&#39;delivery\\\&#39; is applicable for equities. \\\&#39;normal\\\&#39; is applicable for derivatives. \\\&#39;intraday\\\&#39; is applicable for both equity and derivatives
     * @param {PlaceOrderValidityEnum} validity Validity of an order, EOS is applicable for BSE scrips only
     * @param {number} [limitPrice] This is required only for limit and stop limit orders
     * @param {number} [trigPrice] This is required only for stoploss limit and stoploss market orders
     * @param {number} [discQty] Disclosed quantity of an order
     * @param {boolean} [amo] Pass this field as true to place an amo order.
     * @param {number} [mktProt] Market order protection percentage. Applicable only for market orders
     * @param {string} [remarks] Any tag or message to track in orderbook.Allowed length upto 10 Characters. Please note remarks more than 10 characters will be stripped out.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public placeOrder(symId: string, qty: number, side: PlaceOrderSideEnum, type: PlaceOrderTypeEnum, product: PlaceOrderProductEnum, validity: PlaceOrderValidityEnum, limitPrice?: number, trigPrice?: number, discQty?: number, amo?: boolean, mktProt?: number, remarks?: string, options?: RawAxiosRequestConfig) {
        return OrdersApiFp(this.configuration).placeOrder(symId, qty, side, type, product, validity, limitPrice, trigPrice, discQty, amo, mktProt, remarks, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ConvertPositionFromProductEnum = {
    Delivery: 'delivery',
    Intraday: 'intraday',
    Normal: 'normal'
} as const;
export type ConvertPositionFromProductEnum = typeof ConvertPositionFromProductEnum[keyof typeof ConvertPositionFromProductEnum];
/**
 * @export
 */
export const ConvertPositionToProductEnum = {
    Delivery: 'delivery',
    Intraday: 'intraday',
    Normal: 'normal'
} as const;
export type ConvertPositionToProductEnum = typeof ConvertPositionToProductEnum[keyof typeof ConvertPositionToProductEnum];
/**
 * @export
 */
export const ConvertPositionSideEnum = {
    Buy: 'buy',
    Sell: 'sell'
} as const;
export type ConvertPositionSideEnum = typeof ConvertPositionSideEnum[keyof typeof ConvertPositionSideEnum];
/**
 * @export
 */
export const GetOrderMarginSideEnum = {
    Buy: 'buy',
    Sell: 'sell'
} as const;
export type GetOrderMarginSideEnum = typeof GetOrderMarginSideEnum[keyof typeof GetOrderMarginSideEnum];
/**
 * @export
 */
export const GetOrderMarginTypeEnum = {
    Limit: 'limit',
    Market: 'market',
    Stoplimit: 'stoplimit',
    Stopmarket: 'stopmarket'
} as const;
export type GetOrderMarginTypeEnum = typeof GetOrderMarginTypeEnum[keyof typeof GetOrderMarginTypeEnum];
/**
 * @export
 */
export const GetOrderMarginProductEnum = {
    Delivery: 'delivery',
    Intraday: 'intraday',
    Normal: 'normal',
    Bracket: 'bracket',
    Cover: 'cover'
} as const;
export type GetOrderMarginProductEnum = typeof GetOrderMarginProductEnum[keyof typeof GetOrderMarginProductEnum];
/**
 * @export
 */
export const ModifyOrderTypeEnum = {
    Limit: 'limit',
    Market: 'market',
    Stoplimit: 'stoplimit',
    Stopmarket: 'stopmarket'
} as const;
export type ModifyOrderTypeEnum = typeof ModifyOrderTypeEnum[keyof typeof ModifyOrderTypeEnum];
/**
 * @export
 */
export const ModifyOrderValidityEnum = {
    Day: 'day',
    Ioc: 'ioc',
    Eos: 'eos',
    Gtc: 'gtc'
} as const;
export type ModifyOrderValidityEnum = typeof ModifyOrderValidityEnum[keyof typeof ModifyOrderValidityEnum];
/**
 * @export
 */
export const ModifyOrderSideEnum = {
    Buy: 'buy',
    Sell: 'sell'
} as const;
export type ModifyOrderSideEnum = typeof ModifyOrderSideEnum[keyof typeof ModifyOrderSideEnum];
/**
 * @export
 */
export const PlaceOrderSideEnum = {
    Buy: 'buy',
    Sell: 'sell'
} as const;
export type PlaceOrderSideEnum = typeof PlaceOrderSideEnum[keyof typeof PlaceOrderSideEnum];
/**
 * @export
 */
export const PlaceOrderTypeEnum = {
    Limit: 'limit',
    Market: 'market',
    Stoplimit: 'stoplimit',
    Stopmarket: 'stopmarket'
} as const;
export type PlaceOrderTypeEnum = typeof PlaceOrderTypeEnum[keyof typeof PlaceOrderTypeEnum];
/**
 * @export
 */
export const PlaceOrderProductEnum = {
    Delivery: 'delivery',
    Intraday: 'intraday',
    Normal: 'normal'
} as const;
export type PlaceOrderProductEnum = typeof PlaceOrderProductEnum[keyof typeof PlaceOrderProductEnum];
/**
 * @export
 */
export const PlaceOrderValidityEnum = {
    Day: 'day',
    Ioc: 'ioc',
    Eos: 'eos',
    Gtc: 'gtc'
} as const;
export type PlaceOrderValidityEnum = typeof PlaceOrderValidityEnum[keyof typeof PlaceOrderValidityEnum];


/**
 * SymbolDetailsApi - axios parameter creator
 * @export
 */
export const SymbolDetailsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * <ul><li>Get complete list of scrips based on the group passed in path.</li><li>This request accepts two types of response format : text/plain and application/json.</li><li><strong>text/plain</strong> : Normal plain string in csv format, rows separated with newline and columns separated with `,` (comma).</li><li><strong>application/json</strong>: List of scripts in a json array format. But usually slower than plain text format due to its larger size.</li></ul>
         * @summary Scrip Master Data
         * @param {string} scripGroup Enter symbol name to download
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSymbolDetails: async (scripGroup: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scripGroup' is not null or undefined
            assertParamExists('getSymbolDetails', 'scripGroup', scripGroup)
            const localVarPath = `/api/mkt-data/scrips/symbol-store/{scripGroup}`
                .replace(`{${"scripGroup"}}`, encodeURIComponent(String(scripGroup)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * <ul><li>This service can be used to fetch the scrip groups. It requires version number as input. </li><li>Version number is maintained to avoid fetching scrip master data multiple times a day, as  the scrip master data gets updated only once in a day during BOD ( Beginning of Day) process.</li><li>For initial or first api call, version can be passed as \'zero\'. If the version number which is been passed in the query param is not matched with the server data version, isUpdated flag will be true and scrip groups data will be received in the response. </li><li>If the version matches with the server data version, isUpdated flag will be false and scrips groups data array would be empty.</li><li>By using the names in scrip master groups response, user can call Scrip Master Data API to get scrip list.</li><li>For effective usage of ScripMaster, users can persist version number, ScripMaster groups and data locally.</li><strong>idFormat Usage :</strong></br><li>Each scrip group has different symbol-id format. This format is mentioned in the `idFormat` key.</br>Eg: For Equity, the id format is instrument_symbol_series_exchange. </li><li>The user can decompose the symbol-id format by splitting with `_` (underscore) delimiter for identifying attributes of a symbol if required.</br>Eg: If user want to know the instrument and exchange of a symbol from Securities group, the 1st and 4th words can be extracted from symbol-id.</li><li>Note: On BOD (Beginning of Day) process, symbol store will be updated and the version will be incremented in the api server.</li></ul>
         * @summary Scrip Master Groups
         * @param {number} version Enter the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionDetails: async (version: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'version' is not null or undefined
            assertParamExists('versionDetails', 'version', version)
            const localVarPath = `/api/mkt-data/scrips/symbol-store`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (version !== undefined) {
                localVarQueryParameter['version'] = version;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SymbolDetailsApi - functional programming interface
 * @export
 */
export const SymbolDetailsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SymbolDetailsApiAxiosParamCreator(configuration)
    return {
        /**
         * <ul><li>Get complete list of scrips based on the group passed in path.</li><li>This request accepts two types of response format : text/plain and application/json.</li><li><strong>text/plain</strong> : Normal plain string in csv format, rows separated with newline and columns separated with `,` (comma).</li><li><strong>application/json</strong>: List of scripts in a json array format. But usually slower than plain text format due to its larger size.</li></ul>
         * @summary Scrip Master Data
         * @param {string} scripGroup Enter symbol name to download
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSymbolDetails(scripGroup: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSymbolDetails(scripGroup, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SymbolDetailsApi.getSymbolDetails']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * <ul><li>This service can be used to fetch the scrip groups. It requires version number as input. </li><li>Version number is maintained to avoid fetching scrip master data multiple times a day, as  the scrip master data gets updated only once in a day during BOD ( Beginning of Day) process.</li><li>For initial or first api call, version can be passed as \'zero\'. If the version number which is been passed in the query param is not matched with the server data version, isUpdated flag will be true and scrip groups data will be received in the response. </li><li>If the version matches with the server data version, isUpdated flag will be false and scrips groups data array would be empty.</li><li>By using the names in scrip master groups response, user can call Scrip Master Data API to get scrip list.</li><li>For effective usage of ScripMaster, users can persist version number, ScripMaster groups and data locally.</li><strong>idFormat Usage :</strong></br><li>Each scrip group has different symbol-id format. This format is mentioned in the `idFormat` key.</br>Eg: For Equity, the id format is instrument_symbol_series_exchange. </li><li>The user can decompose the symbol-id format by splitting with `_` (underscore) delimiter for identifying attributes of a symbol if required.</br>Eg: If user want to know the instrument and exchange of a symbol from Securities group, the 1st and 4th words can be extracted from symbol-id.</li><li>Note: On BOD (Beginning of Day) process, symbol store will be updated and the version will be incremented in the api server.</li></ul>
         * @summary Scrip Master Groups
         * @param {number} version Enter the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async versionDetails(version: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<IouResponseScripVersionInfo>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.versionDetails(version, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SymbolDetailsApi.versionDetails']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * SymbolDetailsApi - factory interface
 * @export
 */
export const SymbolDetailsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SymbolDetailsApiFp(configuration)
    return {
        /**
         * <ul><li>Get complete list of scrips based on the group passed in path.</li><li>This request accepts two types of response format : text/plain and application/json.</li><li><strong>text/plain</strong> : Normal plain string in csv format, rows separated with newline and columns separated with `,` (comma).</li><li><strong>application/json</strong>: List of scripts in a json array format. But usually slower than plain text format due to its larger size.</li></ul>
         * @summary Scrip Master Data
         * @param {string} scripGroup Enter symbol name to download
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSymbolDetails(scripGroup: string, options?: any): AxiosPromise<string> {
            return localVarFp.getSymbolDetails(scripGroup, options).then((request) => request(axios, basePath));
        },
        /**
         * <ul><li>This service can be used to fetch the scrip groups. It requires version number as input. </li><li>Version number is maintained to avoid fetching scrip master data multiple times a day, as  the scrip master data gets updated only once in a day during BOD ( Beginning of Day) process.</li><li>For initial or first api call, version can be passed as \'zero\'. If the version number which is been passed in the query param is not matched with the server data version, isUpdated flag will be true and scrip groups data will be received in the response. </li><li>If the version matches with the server data version, isUpdated flag will be false and scrips groups data array would be empty.</li><li>By using the names in scrip master groups response, user can call Scrip Master Data API to get scrip list.</li><li>For effective usage of ScripMaster, users can persist version number, ScripMaster groups and data locally.</li><strong>idFormat Usage :</strong></br><li>Each scrip group has different symbol-id format. This format is mentioned in the `idFormat` key.</br>Eg: For Equity, the id format is instrument_symbol_series_exchange. </li><li>The user can decompose the symbol-id format by splitting with `_` (underscore) delimiter for identifying attributes of a symbol if required.</br>Eg: If user want to know the instrument and exchange of a symbol from Securities group, the 1st and 4th words can be extracted from symbol-id.</li><li>Note: On BOD (Beginning of Day) process, symbol store will be updated and the version will be incremented in the api server.</li></ul>
         * @summary Scrip Master Groups
         * @param {number} version Enter the version
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionDetails(version: number, options?: any): AxiosPromise<IouResponseScripVersionInfo> {
            return localVarFp.versionDetails(version, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SymbolDetailsApi - object-oriented interface
 * @export
 * @class SymbolDetailsApi
 * @extends {BaseAPI}
 */
export class SymbolDetailsApi extends BaseAPI {
    /**
     * <ul><li>Get complete list of scrips based on the group passed in path.</li><li>This request accepts two types of response format : text/plain and application/json.</li><li><strong>text/plain</strong> : Normal plain string in csv format, rows separated with newline and columns separated with `,` (comma).</li><li><strong>application/json</strong>: List of scripts in a json array format. But usually slower than plain text format due to its larger size.</li></ul>
     * @summary Scrip Master Data
     * @param {string} scripGroup Enter symbol name to download
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SymbolDetailsApi
     */
    public getSymbolDetails(scripGroup: string, options?: RawAxiosRequestConfig) {
        return SymbolDetailsApiFp(this.configuration).getSymbolDetails(scripGroup, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * <ul><li>This service can be used to fetch the scrip groups. It requires version number as input. </li><li>Version number is maintained to avoid fetching scrip master data multiple times a day, as  the scrip master data gets updated only once in a day during BOD ( Beginning of Day) process.</li><li>For initial or first api call, version can be passed as \'zero\'. If the version number which is been passed in the query param is not matched with the server data version, isUpdated flag will be true and scrip groups data will be received in the response. </li><li>If the version matches with the server data version, isUpdated flag will be false and scrips groups data array would be empty.</li><li>By using the names in scrip master groups response, user can call Scrip Master Data API to get scrip list.</li><li>For effective usage of ScripMaster, users can persist version number, ScripMaster groups and data locally.</li><strong>idFormat Usage :</strong></br><li>Each scrip group has different symbol-id format. This format is mentioned in the `idFormat` key.</br>Eg: For Equity, the id format is instrument_symbol_series_exchange. </li><li>The user can decompose the symbol-id format by splitting with `_` (underscore) delimiter for identifying attributes of a symbol if required.</br>Eg: If user want to know the instrument and exchange of a symbol from Securities group, the 1st and 4th words can be extracted from symbol-id.</li><li>Note: On BOD (Beginning of Day) process, symbol store will be updated and the version will be incremented in the api server.</li></ul>
     * @summary Scrip Master Groups
     * @param {number} version Enter the version
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SymbolDetailsApi
     */
    public versionDetails(version: number, options?: RawAxiosRequestConfig) {
        return SymbolDetailsApiFp(this.configuration).versionDetails(version, options).then((request) => request(this.axios, this.basePath));
    }
}



